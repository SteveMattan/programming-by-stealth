# PBS 168 of X — YAML: Introduction

As part of our re-building of XKPasswd we are making use of all sorts of developer tooling. The intention is that when we're done, we'll have explained all the pieces of that tooling within the series.

There are two ways in which YAML intersects with this series:

1. Many modern developer tools use YAML for their configuration files
2. Many modern Markdown-based static site generators use YAML for configuration and for metadata, including Jekyll, the Static Site Generator that powers GitHub Pages. This series is written in Markdown and published as a GitHub Pages using a custom Jekyll Theme.

YAML is designed for more than just config files and data representation, but those are the features we'll be confining ourselves to here.

TO EXPAND

## Matching Podcast Episode

TO DO

## Instalment Resources

* The instalment ZIP file — [pbs168.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs168.zip) TO GENERATE IF NEEDED

## Some Historical Context

Before we explore YAML, I think it helps to place it within a larger historical context. YAML didn't arrive into a vacuum, its design was informed by the pain-points exposed by its predecessors. After all, we've been trying to find ways of representing data in text files for decades!

In the earliest days of computing we used primitive data formats like **fixed-width field text files**:

```text
Timestamp           Severity Message
2023-12-25T23:30:03 INFO     Carrot & Cookie placed on mantle piece
2023-12-25T23:45:42 NOTICE   Vibration detected by roof sensor
2023-12-25T23:50:32 NOTICE   Motion detected by chimney sensor     
```

The way this worked is that there's some documentation on someone's desk that says the first field will be 19 characters long, then there will be a space, them the second field will be 8 characters long, then there will be a space, then the final field will fill the rest of the line.

These kinds of formats are very human-readable, but, they're also spectacularly brittle — one line of code somewhere that doesn't check a field length and everything breaks. Not to mention how difficult it is to change your mind about the structure of the data — extending or adding a fields requires a careful review of every single line of code that processes the file to make sure all the offsets are corrected.

In my entire professional life I have encountered just one production system using fixed-width fields, and we did need to alter the structure, and it was an absolute nightmare!

As well as being brittle these files are also very limited — they can only represent tabular data containing strings and numbers, they can't represent lists of dictionaries.

Because fixed-width fields were so difficult to work with they were soon followed by **Tab-Separated Values** (TSV), and shortly after that, Coma-Separated Values (CSV) files.

A TSV file (also called a *tab file*) looks superficially similar to a fixed-width field file, but instead of counting characters, the fields are separated by tab characters:

```tsv
Timestamp	Severity	Message
2023-12-25T23:30:03	INFO	Carrot & Cookie placed on mantle piece
2023-12-25T23:45:42	NOTICE	Vibration detected by roof sensor
2023-12-25T23:50:32	NOTICE	Motion detected by chimney sensor 
```

TSV files are less brittle because you don't need to count character offsets anymore, but you now have twi new problems:

1. Your data can't contain tabs
2. Humans can't see the difference between tabs and spaces easily, so debugging corrupted TSV files can be infuriating!

**Coma-Separated Values (CSV)** improve on TSV files a little more by making two changes:

1. Fields are separated with comas not tabs, this makes them easier for humans to debug
2. The specification includes support for quoting field data so it can include comas and even escaped quotation marks

This gives us what is now by far the most widely used generic text format for tabular data:

```csv
Timestamp,Severity,Message
2023-12-25T23:30:03,INFO,"Carrot & Cookie placed on mantle piece"
2023-12-25T23:45:42,NOTICE,"Vibration detected by roof sensor"
2023-12-25T23:50:32,NOTICE,"Motion detected by chimney sensor"
```

However, note that both TSVs and CSVs have sacrificed readability for robustness, because the field boundaries no longer line up, you need to count separators to know which column you're reading. And, like fixed-width fields, TSVs and CSVs are limited to tabular data.

The next text-based data format really take off was the **Extensible Markup Language**, or XML.

Because of it's enthusiastic adoption by major enterprise vendors like Sun Microsystems in Java, Oracle in their various enterprise platforms, and Microsoft in IIS, XML is still doing a lot of heavy lifting to this day!

XML is not built around the idea of lines with separated fields, instead, it uses nested tags. This means you can represent just about any data structure you like in XML. And, with some sensible indentation and some syntax highlighting it's actually quite human readable:

```xml
<message>
  <timestamp>2023-12-25T23:30:03</timestamp>
  <severity>INFO</severity>
  <message>Carrot &amp; Cookie placed on mantle piece</message>
</message>
  <timestamp>2023-12-25T23:45:42</timestamp>
  <severity>NOTICE</severity>
  <message>Vibration detected by roof sensor</message>
<message>
  <timestamp>2023-12-25T23:50:32</timestamp>
  <severity>NOTICE</severity>
  <message>Motion detected by chimney sensor</message>
</message>
```

So, while XML is powerful and pretty human-readable, it's also extremely verbose! The power and the human-readableness come at the price of wasted disk space and/or bandwidth.

The next contender to really make a splash was **JSON**, which we've already made heavy use of throughout this series.

Like XML, JSON can represent complex data types and is very human-readable. But it does so while being much less verbose, and hence, less inefficient:

```json
[
  {
    "timestamp": "2023-12-25T23:30:03",
    "severity": "INFO",
    "message": "Carrot & Cookie placed on mantle piece"
  },
  {
    "timestamp": "2023-12-25T23:45:42",
    "severity": "NOTICE",
    "message": "Vibration detected by roof sensor"
  },
  {
    "timestamp": "2023-12-25T23:50:32",
    "severity": "NOTICE",
    "message": "Motion detected by chimney sensor"
  }
]
```

Finally, we get to **YAML**, which takes things just that little bit further by being even more human-readable, and even more efficient than JSON:

```yaml
- timestamp: 2023-12-25T23:30:03
  severity: INFO
  message: Carrot & Cookie placed on mantle piece
- timestamp: 2023-12-25T23:45:42
  severity: NOTICE
  message: Vibration detected by roof sensor
- timestamp: 2023-12-25T23:50:32
  severity: NOTICE
  message: Motion detected by chimney sensor
```



## Final Thoughts

TO DO
