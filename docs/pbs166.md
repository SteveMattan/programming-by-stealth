## PBS 166 of X — jq: Processing Arrays & Dictionaries sans Explosions

TO DO

## Matching Podcast Episode

TO DO

## Installment Resources

* The instalment ZIP file — [pbs166.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs166.zip) TO CREATE

## PBS 165 Challenge Solution

The challenge set at the end of [the previous installment](./pbs165) was to write a jq script that searches a jq domain monitoring export for all users caught up in a breach that meets two criteria:

1. the name of the breach matches a given search string (ignoring case)
2. the breach contained passwords

The script should return an array of dictionaries, one for each user-to-breach match that contains the following keys:

* `AccountName`: the user's email account name
* `BreachName`: the name of the matching breach
* `BreachTitle`: the title of the matching breach
* `BreachedDataClasses`: the list of breached data classes

In order to determine if a breach contained passwords, the data in the domain monitoring export needs to be enriched with the full database of breaches known to the HIBP service. As we learned in [instalment 164](./pbs164), this can be downloaded for free from the HIBP API, but for convenience, the instalment ZIP includes a copy of the database as it was on the 18th of May 2024 in the file `hibp-breaches-20240518.json`.

The suggestion was to use a solution to the bonus challenge from [instalment 164](./pbs164) as a starting point.

You'll find a sample solution in the instalment ZIP as `pbs165-challengeSolution-Basic.jq`:

```jq
# Find users caught up in any breach that leaked passwords that matches a given
# search string.
# Input:    JSON as downloaded from the HIBP service
# Output:   An array of account dictionaries describing each matching breach 
#   event. Each dictionary will be indexed by:
#   - AccountName:          The part of the email address to the left of the @
#   - BreachName:			The breach's unique name in the HIBP DB
#   - BreachTitle:          The human-friendly title of the breach
#   - BreachedDataClasses:	An array of compromised data types as strings
# Variables:
# - $breachSearch   The string to search breach names by un a case-insensitive way
# - $breachDetails	An array containing a single entry, the JSON for the
#                   latest lookup table of HIBP breaches indexed by breach
#                   name

# transform the lookup of breaches by AccountName into a list of entries:
# - keys will be account names
# - values will be arrays of breach IDs
.Breaches | to_entries

# filter down to just the users caught up in breaches matching the given search string that leaked passwords
| [
	# explode the list of entries
	.[]

	# save the current account name to a variable
	| .key as $accountName

	# explode the breache names for the current entry
	| .value[]

	# keep only the names for breaches that meet the search criteria
	| select(
		# breaches that match the search string
		(ascii_downcase | contains($breachSearch | ascii_downcase))

		# breaches with passwords
		and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
	)

	# build the dictionary to return
    | {
		AccountName: $accountName,
		BreachName: .,
		BreachTitle: $breachDetails[0][.].Title,
		BreachedDataClasses: $breachDetails[0][.].DataClasses
	}
]
```

Before we explore this code, let's see it in action, and before we do that, let's remind ourselves of the data we're processing.

The file `hibp-pbs.demo.json` contains a ficrtionalised breach export for the imagined domain `demo.bartificer.net` which was generated by anonymising a genuine export for a different domain. The `.Breaches` key in the export is a lookup table that maps the username part of email addresses on the domain (the part to the left of the `@`) to lists of breach names as strings:

```json
{
  "Breaches": {
    "josullivan": [
      "OnlinerSpambot"
    ],
    "egreen": [
      "Dropbox"
    ],
    "mwkelly": [
      "Dropbox",
      "KayoMoe",
      "LinkedIn",
      "LinkedInScrape",
      "PDL"
    ],
    "ahawkins": [
      "iMesh",
      "OnlinerSpambot"
    ],
    "ptraynor": [
      "Collection1"
    ]
  },
  "Pastes": {}
}
```

The breach names in the `.Breaches` lookup table are the unique names for the breaches in the HIBP database, and they are the keys in the lookup table of all breaches downloaded from the HIBP API and saved as `hibp-breaches-20240518.json`. Each entry in this lookup table has the following relevant keys; `Name`, `Title` &  `DataClasses`, e.g.:

```json
{
  …
  "Name": "Dropbox",
  "Title": "Dropbox",
  "DataClasses": [
    "Email addresses",
    "Passwords"
  ]
  …
}
```

Let's now prove that the sample solution works by searching for all users caught up in any breach that matches the search string `'linkedin'` and contains passwords:

```sh
jq -f pbs165-challengeSolution-Basic.jq --slurpfile breachDetails hibp-breaches-20240518.json --arg breachSearch linkedin hibp-pbs.demo.json
# [
#   {
#     "AccountName": "mwkelly",
#     "BreachName": "LinkedIn",
#     "BreachTitle": "LinkedIn",
#     "BreachedDataClasses": [
#       "Email addresses",
#       "Passwords"
#     ]
#   }
# ]
```

Why did this only return one result when `mwkelly` is caught up in two breaches that match our search string (`LinkedIn` & `LinkedInScrape`)? Well, if we query the breach DB directly, we can see that the *'missing'* breach did not contain passwords:

```sh
jq '.LinkedInScrape.DataClasses' hibp-breaches-20240518.json
# [
#   "Education levels",
#   "Email addresses",
#   "Genders",
#   "Geographic locations",
#   "Job titles",
#   "Names",
#   "Social media profiles"
# ]
```

To see what happens when a single user is caught up in multiple matching breaches, let's search for the (artifically simple) string `'o'`, this will match `DropBox` , `KayoMoe` & `OnlinerSpambot`, all of which contain passwords:

```sh
jq -f pbs165-challengeSolution-Basic.jq --slurpfile breachDetails hibp-breaches-20240518.json --arg breachSearch o hibp-pbs.demo.json
# [
# …
# {
#     "AccountName": "mwkelly",
#     "BreachName": "Dropbox",
#     "BreachTitle": "Dropbox",
#     "BreachedDataClasses": [
#       "Email addresses",
#       "Passwords"
#     ]
#   },
#   {
#     "AccountName": "mwkelly",
#     "BreachName": "KayoMoe",
#     "BreachTitle": "Kayo.moe Credential Stuffing List",
#     "BreachedDataClasses": [
#       "Email addresses",
#       "Passwords"
#     ]
#   },
#   …
# ]
```

Because the search term was so generic, many breaches matched, so the output shown above is truncated to show only the two matching entries for `mwkelly`.

Now that we know the script works as desired, let's look at how it works.

Big-picture wise the script converts the `.breaches` lookup table to an array of entries and then explodes it and captures the remaining transformed pieces. The intersting part of te script is how each entry is processed once it's exploded.

Because we want to capture each matching user-breach combination, we will need to explide the list of breaches (`.value` in the entries), but we also need to remember the user the breaches belong to, so we need to save the username (`.key` in the entries) to a variable before we explode the breaches:

```jq
# explode the list of entries
.[]

# save the current account name to a variable
.key as $accountName

# explode the breache names for the current entry
.value[]
```

Next, we need to filter the breaches down to just those that match our criteria. Because we are processing one breach at a time now, we can use a simple call to `select` without needing to use `any` like we did in our starting point. Note that since we exploded the list of breaches in the previous filter in the chain, the value currently being processed (`.`) is a breach name. So, we need to filter on two conditions — a name match, and whether or not the breach contains a password (the logic is retained from the starting point):

```jq
# keep only the names for breaches that meet the search criteria
| select(
  # breaches that match the search string
  (ascii_downcase | contains($breachSearch | ascii_downcase))

  # breaches with passwords
  and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
)
```

Note the use of data enrichment via `$breachDetails[0]` which gets passed on the commandline with `--slurpfile`

Finally, we need to build the required dictionary for the matching breaches:

```jq
# build the dictionary to return
| {
  AccountName: $accountName,
  BreachName: .,
  BreachTitle: $breachDetails[0][.].Title,
  BreachedDataClasses: $breachDetails[0][.].DataClasses
}
```

Note the use of both our saved variable, and yet more data enrichment.

For bonus credit, the additional challenge was to search both the name and title for a match. This is because the name visible on the HIBP website is actually the `Title`, and unlike the `Name` it can contain spaces and characters other than just letters and numbers. You'll find the full solution in the file `pbs165-challengeSolution-Bonus.jq` in the instalment ZIP. 

Before we look at the one change needed to get the bonus credit, let's see why this functionality was worth adding with an example.

On the HIBP website there is a breach labled *'Kayo.moe Credential Stuffing List'*, but if you search for that with `'kayo.moe'` using our basic solition nothing is matched, even though `mwkelly` is caught up in that breach:

```sh
jq -f pbs165-challengeSolution-Basic.jq --slurpfile breachDetails hibp-breaches-20240518.json --arg breachSearch 'kayo.moe' hibp-pbs.demo.json
# []
```

But, if we use our bonus solution we do see that `mwkelly` was caught up in the breach:

```sh
jq -f pbs165-challengeSolution-Bonus.jq --slurpfile breachDetails hibp-breaches-20240518.json --arg breachSearch 'kayo.moe' hibp-pbs.demo.json
# [
#  {
#    "AccountName": "mwkelly",
#    "BreachName": "KayoMoe",
#    "BreachTitle": "Kayo.moe Credential Stuffing List",
#    "BreachedDataClasses": [
#      "Email addresses",
#      "Passwords"
#    ]
#  }
# ]
```

There is only one change between the basic and bonus sollutions — an extra caluse in the `select`:

```jq
# the basic solution
| select(
  # breaches that match the search string
  (ascii_downcase | contains($breachSearch | ascii_downcase))

  # breaches with passwords
  and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
)

# the bonus solution
| select(
  # breaches that match the search string
  (
    # check the name
    (ascii_downcase | contains($breachSearch | ascii_downcase))

    # check the title
    or ($breachDetails[0][.].Title | ascii_downcase | contains($breachSearch | ascii_downcase))
  )

  # breaches with passwords
  and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
)
```

## Manipulating Without Exploding

LEFT OFF HERE !!!

At this stage in our jq journey we've met many operators and functions which can manipulate data, but each time we've applied a transformation to each element in an array we've done so by exploding it apart updating each piece, and then re-assembling it. We've never even considered applying the same transformation to every value in a dictionary, because based purely on what we've learned so far, we couldn't put the dictionary back together again!

What if you could edit the contents of arrays and dictionaries without ever needing to explode them? As you've probably guessed from the setup, you can! And, this entire instalment is dedicated to doing just that with two of jq's most powerful functions, `map` & `map_values`.

MAYBE — cover `reduce` too

## Altering Each Element in an Array with the `map` Function

In most programming languages, you need to loop over arrays to manipulate their contents, but in jq you don't need to do that — you can simply pipe an array to the `map` function and describe the desired transformation with a filter passed as the first argument.

Within a the filter passed as the first argument to `map`,  `.` represents *'the array element being processed'*, and the filter will be applied to each element in the array. The function then outputs the updated array.

In effect, `map` lets you **loop over an aray in a single function call**, and **process each element without exploding the array**.

For example, we can convert all the numbers in an array to their absolute values with:

```sh
# -n tells jq not to expect any input
# -c tells jq to render the output in a compact format
jq -nc '[1, -2, 3, -42] | map(. | abs)'
# outputs [1,2,3,42]
```

One of the most common uses of `map` is in conjunction with `select`, allowing you filter an array down to only the elements that meet a particular criteria without needing to explode and then re-assemble it.

As an example, let's filter the Nobel Prizes data set down to an array with just the physics prizes, with their order reversed so the older prize comes first, and the newest last. Here's how we would do that without using `map`:

```sh
jq '[.prizes[] | select(.category == "physics")] | reverse' NobelPrizes.json
```

Note the need to explode the prizes with `.prizes[]`, and then to re-assemble the array by wrapping the exposion and the `select` filters in square brackets ( `[` & `]`).

With `map`, we can simplify things:

```sh
jq '.prizes | map(select(.category == "physics")) | reverse' NobelPrizes.json
```

We now have a simple filter chain without the need for nesting part of it within square brackets, making it easier to read and to maintain.

Note that this technique works because the `select` function returns `empty` rather than `null` when called with a value that does not match the specified criteria, transforming un-matched entries into absolute nothingless, hence deleting them!

One final point to note — `map` will not give an error when the input is a dictionary, it will simply treat the values within the key-value pairs as array elements, and output an array of their processed results. At first glance this might seem useless, how often do you have a dictionary who's keys you don't need? But actually, it is occassionaly useful, imagine you have weekly sales data in dictionary indexed by day-of-the-week, like so (`weeklySales.json` in the instalment ZIP):

```json
{
  "mon": 2343,
  "tue": 4324,
  "wed": 4121,
  "thur": 8762,
  "fri": 11452,
  "sat": 32394,
  "sun": 0
}
```

To convert this to an array of numbers we can call `map` with a filter that passes the values through un-changed, i.e. simply `.`:

```sh
jq -c 'map(.)' weeklySales.json # outputs [2343,4324,4121,8762,11452,32394,0]
```

Notice that the values in the array are in the order the keys were added to the dictionary, not in any kind of sorted order.

## The `map_values` Function

In many ways the `map_values` function is very similar to the `map` function, but while `map` is primarily designed for processing arrays, `map_values` is primarily designed for processing dictionaries.

It's structure is the same — the input should be a dictionary, and its argument is a filter to be applied to each value in the dictionary to produce a new value in the output dictionary, and within the filter, `.` is the value currently being processed.

So, to double all the sales data in our weekly sales dictionary, we would run the command:

```sh
jq 'map_values(. * 2)' weeklySales.json
```

This produces the following dictionary:

```json
{
  "mon": 4686,
  "tue": 8648,
  "wed": 8242,
  "thur": 17524,
  "fri": 22904,
  "sat": 64788,
  "sun": 0
}
```

Similar to how `map` does not throw an error when passed a dictionary, `map_values` will not throw an error when you pass it an array, it will simply process the array, and return an updated array (not a dictionary).

## Beware the Subtle Difference between `map` & `map_values` 

With `map`, when a filter maps a single input values to multiple output values, they all appear in the output array, but `map_values` will only include the first generated value for each input.

As a somewhat contrived example to illustrate this difference, let's pass an array of arrays to both functions and see what happens when we use a filter that explodes these sub-arrays:

```sh
# use map to explode sub-arrays
jq -nc '[[1], [2, 2], [3, 3, 3]] | map(.[])' # outputs [1,2,2,3,3,3]

# try use map_values to explode sub-arrays
jq -nc '[[1], [2, 2], [3, 3, 3]] | map_values(.[])' # outputs [1,2,3]
```

## The `reduce` Function 

TO DO - MAYBE

## An Optional Challenge

TO DO

## Final Thoughts

TO DO
