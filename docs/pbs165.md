## PBS 165 of X — jq: Variables

TO DO

## Matching Podcast Episode

TO DO

## Installment Resources

* The instalment ZIP file — [pbs165.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs165.zip) TO CREATE

## PBS 164 Challenge Solution

The challenge set at the end of the previoius instalment was to craete a jq script that finds all users caught in a breach that matches a given search pattern case-insensitively.

This challenge encompassed five key concepts we've covered thus far in the seriues:

1. Converting a lookup-table-style dictionary into an array of entry-type dictionaries with `to_entries`. 
2. The design pattern of exploding an array, processing its contents in some way, and then re-collecting the pieces afterwards using array construction — i.e. code of the form: `[ .[] | … ]`.
3. The use of the two-argument version of `any` within a `select` to filter items that contain an array based on the value of any one elemenmt within the array.
4. The use of `ascii_downcase` on both strings being compared to make the comparison case-insensitive.
5. The use of the `--arg` commandline option to pass a variable into jq.

With all that in mind, you'll find a sample solution in the instalment ZIP as `pbs164-challengeSolution-Basic.jq`:

```jq
# Find users caught up in any breach that matches a given search string.
# Input:    JSON as downloaded from the HIBP service
# Output:   An array of account names (the parts of email addresses to the left of the @).
# Variables:
# - $breachSearch		The string to search breach names by un a case-insensitive way

# transform the lookup of breaches by AccountName into a list of entries:
# - keys will be account names
# - values will be arrays of breach IDs
.Breaches | to_entries

# select only the entries for users caught up in a breach with a matching ID
| [
  # explode the list of entries
  .[]

  # select only the entries for users caught up in the given breach
  | select(any(.value[]; . | ascii_downcase | contains($breachSearch | ascii_downcase)))

  # keep just the account name
  | .key
]
```

To run this script against the demo Have-I-Been-Pwnd domain breach export in the file `hibp-pbs.demo.json`  to find all users caught up in a breach that contains `drop` in its breach ID use the command:

```sh
jq -f ./pbs164-challengeSolution-Basic.jq --arg breachSearch drop hibp-pbs.demo.json
```

This produces the output:

```json
[
  "egreen",
  "mwkelly"
]
```

With the comments removed, there is actually very little code in the script:

```jq
.Breaches | to_entries
| [
	.[]
	| select(any(.value[]; . | ascii_downcase | contains($breachSearch | ascii_downcase)))
  | .key
]
```

For context, the sample breach report used as input looks like this:

```json
{
    "Breaches": {
      "josullivan": [
        "OnlinerSpambot"
      ],
      "egreen": [
        "Dropbox"
      ],
      "mwkelly": [
        "Dropbox",
        "KayoMoe",
        "LinkedIn",
        "LinkedInScrape",
        "PDL"
      ],
      "ahawkins": [
        "iMesh",
        "OnlinerSpambot"
      ],
      "ptraynor": [
        "Collection1"
      ]
    },
    "Pastes": {}
  }  
```

We are only interested in `.Breaches`, which is a lookup-table-style dictionary index by the username part of emails addresses (the bit to the right of the `@`), mapping to arrays of breach IDs in the HIBP database.

We start by converting this lookup table into an array of entries with `to_entries`, where each entry will have a form like:

```json
{
  "key": "mwkelly",
  "value": ["Dropbox","KayoMoe","LinkedIn","LinkedInScrape","PDL"]
}
```

We then need to keep only the entries that contain at least one breach matching the search string. To keep or discard an entire entry we need to use the `select` function with a condition as its only argument. The condition needs to check if any string in the `.value` array matches our string, so to do that we use the two-argument version of the `any` function to evaluate to `true` if any item in our array meets our criteria.

As a reminder, the first argument in the two-argument form of `.any` needs to be a filter that produces one or more value to test, and the second argument is a filter that performs the test. In this case, we need to check every string in the `.value` array, so the first argument is simply that array exploded (`.value[]`).

The second argument needs to be a filter that check the current value being tested (`.`) against the passed searsch string in a case-insensitive way. The key here is to start by converting the current value to lower case by piping it to `ascii_downcase` before piping it to the `contains()` function to check if it contains the lowercased version of our search string (`$breachSearch`).

At this stage, only entries matching our search string remain. We only want the email usernames, which are in the `.key` key of each entry, so we select just that key as the last step within the exploded entries.

All our processing is wrapped in square braches so the remaining email usernames get grouped into an array.

For bonus credit, there was a second challenge, to expand this solution to ignore any breach that does not contain passwords.

The key to this bonus challenge is to use the `--slurpfile` commandline flag to import a downloaded version of the HIBP breach database and use it for data enrichment. You'll find a copy of this database in the file `hibp-breaches-202040329.json` in the installment ZIP.

You'll find a sample solution for bonus credit in the instalment ZIP as `pbs164-challengeSolution-Bonus.jq`:

```jq
# Find users caught up in any breach that leaked passwords that matches a given search string.
# Input:    JSON as downloaded from the HIBP service
# Output:   An array of account names (the parts of email addresses to the left of the @).
# Variables:
# - $breachSearch   The string to search breach names by un a case-insensitive way
# - $breachDetails	An array containing a single entry, the JSON for the
#                   latest lookup table of HIBP breaches indexed by breach
#                   name

# transform the lookup of breaches by AccountName into a list of entries:
# - keys will be account names
# - values will be arrays of breach IDs
.Breaches | to_entries

# filter down to just the users caught up in breaches matching the given search string that leaked passwords
| [
	# explode the list of entries
	.[]

	# select only the entries for users caught up in a breach with a matching ID
	| select(any(.value[];
		# breaches that match the search string
		(. | ascii_downcase | contains($breachSearch | ascii_downcase))

		# breaches with passwords
		and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
	))

	# keep just the account name
  | .key
]
```

We can use this script to find any users caught up in a breach with an ID that contains *'onliner'* that contained passwords with the command:

```sh 
jq -f ./pbs164-challengeSolution-Bonus.jq --slurpfile breachDetails hibp-breaches-202040329.json --arg breachSearch onliner hibp-pbs.demo.json
```

This will return two users caught up in the `OnlinerSpambot` breach which did contain passwords:

```json
[
  "josullivan",
  "ahawkins"
]
```

Notice that this script contains just two change from the basic version.

Firstly, the `--slurpfil` commandline argument is used to pass the database of all breaches to the script as the variable `$breachDetails[0]`. Remember that `--slurpfile` always wraps the contents loaded from the JSON file in an array in case the JSON file contained more than one element. In this case the JSON file contains a dictionary of breach data indexed by Breach ID. For each breach the following keys are defined:

```json
["AddedDate","BreachDate","DataClasses","Description","Domain","IsFabricated","IsMalware","IsRetired","IsSensitive","IsSpamList","IsSubscriptionFree","IsVerified","LogoPath","ModifiedDate","Name","PwnCount","Title"]
```

The one we're intersted in is `DataClasses`, which is an array of strings defining the types of data caugh up in the breach, and for our purposes, we only care that any breach which contained passwords will have a `.DataClasses` array that contains that string `"Passwords"`.

You can see this for yourself by extracting the data classses for the OnlinerSpambot breach with the command:

```sh
jq '.OnlinerSpambot.DataClasses' hibp-breaches-202040329.json
```

This shows that t hat breach contained the following:

```json
[
  "Email addresses",
  "Passwords"
]
```

We can also see that the `PDL` breach that the user `mwkelly` was caught up on does not contain passwords:

```sh
jq '.PDL.DataClasses' hibp-breaches-202040329.json
#[
#  "Email addresses",
#  "Employers",
#  "Geographic locations",
#  "Job titles",
#  "Names",
#  "Phone numbers",
#  "Social media profiles"
#]
```

This lets us verify that the bonus script works as intended. If we use the basic script to search for `pdl` we get one user:

```sh
jq -f ./pbs164-challengeSolution-Basic.jq --arg breachSearch pdl hibp-pbs.demo.json
#[
#  "mwkelly"
#]
```

But if we use th bonus solution we get none:

```sh
jq -f ./pbs164-challengeSolution-Bonus.jq --slurpfile breachDetails hibp-breaches-202040329.json --arg breachSearch pdl hibp-pbs.demo.json
# []
```

Now, let's look at the second change, the part of the script that makes use of the extrenal data file to filter the results — the test within the call to `select`. In the basic version this call was simply:

```jq
| select(any(.value[]; . | ascii_downcase | contains($breachSearch | ascii_downcase)))
```

But in the bonus version there is much more logic embedded within it:

```jq
| select(any(.value[];
  # breaches that match the search string
  (. | ascii_downcase | contains($breachSearch | ascii_downcase))

  # breaches with passwords
  and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
))
```

The single condition in the basic version has been replaced with two conditions, each grouped within parentheses, and separated from each other by the `and` operator. The first condition is the original one, it's the second condition that's new:

```jq
$breachDetails[0][.].DataClasses | contains(["Passwords"])
```

The first thing to note is that all this is happening inside the call to `any()` which is checking each breach ID in the list of breaches for a user one-by-one, so the value of *the item currently being processed*, i.e. `.` is a breach ID like `"Dropbox"` , `"LinkedIn"`, or `"PDL"`.

This means the details of the breach currently being checked are in `$breachDetails[0][.]`, and the list of data types the breach contained is in `$breachDetails[0][.].DataClasses`.

Remember that when the input and the argument to the `contains` function are both strings it checks if the argument is a sub-string of the input, but when the input and the argument are both arrays, it checks if the input array contains every element in the argument array. We want to check the array of breached data types for the single string `"Passwords"`, so we pipe the entire array of breached data types to the `contains()` function and give it the argument `["Passwords"]`.

## How jq Thinks About Variables

As mentioned previously, jq has been designed to very rarely need variables — jq filter inputs and outputs are automatically plumbed together, and sub-expressions within the same filter see the same input, so they effectively share data automatically. This means that most of the time, you simply don't need variables, and if you're using them, you're probably over-complicating your code! Or, as the documentation puts it:

> "there's generally a cleaner way to solve most problems in jq than defining variables"

The example the documentation gives is the simple task of averaging an array of numbers.

In most languages this simple task requires at least one, and usually two variables. To illustrate this point, let's blow the dust off our JavaScript skills and write a little commandline JavaScript script to average an array of numbers in JSON format. We'll use the NodeJS JavaScript runtime to do this. 

A few things to know befor we start:

1. NodeJS scripts can read the contents of any stream, including STDIN, using the `readFileSync()` function in Node's standard file system module `fs`
2. NodeJS represents STDIN with the `process.stdin` object, who's `fd` (file descriptor) property can be passed to the `readFileSync()` function to instruct it to read from STDIN
3. By default, NodeJS sends the output from the `console.log` function to STDOUT

With that in mind, you'll find the code for our simple NodeJS averaging script in the instalment ZIP as `pbs165-a-average.js`:

```js
// A script to read the JSON for an array of numbers from STDIN and write their
// average to STDOUT

// read and parse STDIN
const numArray = JSON.parse(require('fs').readFileSync(process.stdin.fd, 'utf-8'));

//  calculate and output the average
let total = 0;
for(const num of numArray){
    total += num;
}
console.log(total/numArray.length);
```

We can use this script to average the numbers 1, 2, and 3 like so:

```sh
echo "[1, 2, 3]" | node pbs165-a-average.js
# 2
```

This outputs the correct average, 2.

Note that our code contains two variables:

1. A variable to hold the running total as we loop over the nubers
2. A variable to hold the array of numbers so we can both loop over it and access its `length` property

We definitely can't avoid the first variable, but what happens if we try avoid the second? What would happen is we made that second array anonymous by reading, parsing, and looping over it all at once without ever storing it in a variable?

We can calculate the total this way:

```js
let total = 0;
for(const num of JSON.parse(require('fs').readFileSync(process.stdin.fd, 'utf-8'))){
    total += num;
}
```

But we can't calcualte the average this way, because we have no way of knowing the length, so we're forced to add another variable to count the numbers. You can see this alternative code in  `pbs165-a-average-alt.js`:

```js
// A script to read the JSON for an array of numbers from STDIN and write their
// average to STDOUT

// read, parse, and process STDIN
let count = 0;
let total = 0;
for(const num of JSON.parse(require('fs').readFileSync(process.stdin.fd, 'utf-8'))){
    count++;
    total += num;
}

// calculate and output the average
console.log(total/count);
```

The key point is that while we can change which two variables we need, we still need two!

### Look Mom — no Variables!

How many does jq need to acomplish the same task? None!

As proof, you'll find working code to average an array of numbers in `pbs165-a-average.jq` in the instalment ZIP:

```jq
# output the average of an array of numbers passed as input
add/length
```

Before we look at why such simple code works, let's just prove to ourselves that it really does work with:

```sh
echo "[1, 2, 3]" | jq -f pbs165-a-average.jq
# 2
```

There we have it — an average with just two function calls and one operator, and not single variable needed!

This works because both the `add` and `length` functions receive the filter's input, i.e. they both get the full array anonymously.

### Remidner — We Already Undestand the Usefullness of Externally Defined Variables

Before we go on, let's reminder ourselves of something we already know — it can be very useful to access variables defined elsewhere from within our jq code. We've already seen two common uses of such externally defined variables:

1. Using the commandline arguments `--arg` & `--argjson` to pass values as named variables into our filters/scripts to make them more re-usable
2. Using the commandline argument (`--slurpfile`) to load JSON data from external files into our filters/script as named variables for data enrichment

### Rarely is not Never!

With all that said, we also know that there are times when you really do need a variable to store a valute from one filter in your chanin for re-use later in the chain. The reason we are learning about variables at this point in the series is that it is not possible to transfrom a lookup table indexed on one one-to-many key to an equivalent lookuptable indexed on a different one-to-many key. Specifically, without variables, we can't transform a Have-I-Been-Pwned export in its default format, mapping breach names to arrays of user names to a lookup table mapping usernames to arrays of breach names without using a variable.

So,  while the need for internal jq variable definitions is rare, it is real, and as we're about to learn, it can be done using the `as` keyword. But, my advice is still to always stop and think before using `as` — ask yourself *'do I really need a variable, or am I not thinking in a jq-way?'*.

## Defining Variables Within jq Code With `as`

Before we look at how `as` works I want to take a moment to clarify some jargon, otherwise you'll have a hard time finding the relevant sections in the jq manual.

Most languages use the term *assignent operator* to refer to the language's operator(s) for assigning values to variables, but jq is different. We've already met jq's suite of assignment operators, including `=`, `|=`, `+=`, and many more, but they have nothing to do with variables — they manipulate the data flowing through your filters instead. 

So if jq does not use the term *assignemt* for assigning values to variables, what term does it use? **In jq you *bind* values to variable names using the symbolic binding operator `as`**.

The `as` operator behaves similarly to the `debug` function in that behaves as a pass-through, the input it receives passes unchanged to the output it returns. But, it has a desired side-effect. For the `debug` function the side-effect is that a message gets written to STDOUT, and for `as` the side effect is that a new variable exists for all filters to the right of the `as` in your chain.

The syntax for `as` is quite simple, to the left is an expression that generates a value, and to the right is a variable name:

```text
EXPRESSION as $variableName
```

Remember that in jq **all variable names must start with a dollar symbol** (`$`).

TO DO — simple example

### The `as` Opperator Loops

When the expression to the left of the `as` operator generates one value the input gets passed through in-changes and the rest of the filter chain runs with the variable bound to that one value. 

But, when the expression returns multiple values, it behaves similarly to a filters that explodes an array — the filters to the right in the chain get run multiple times.

When you explode an array it's the input passed to the next filter in the chain that changes each time, but `as` does something subtly and importantly different. 

When the expression to the left of the `as` returns multiple values, the remaining filters in the chain run once for each value — each time **the input is the same**, but **the value bound to the variable changes**.

TO DO — looped example

## A Practical Example — Transforming a HIBP Export

As mentioned previously, when you export a breach report for one of your domains in Troy Hunt's Have-I-Been-Pwnd service in JSON format the `.Breaches` key is a lookup-type dictionary that indexes an array of breach names by the username part of the breaches email address, i.e. the part to the left of the `@`. 

This default output is perfect for answering  questions like *'what breaches has Bob been snared in?'*, but it's terrible for answering questions of the form *'who all is caught up in the big breach discovered last week?'*.

The needed information is all there, but it's in a very inconvenient shape for these kinds of questions. So, let's combine what we learned in previous instalments with what we've just learned to transform our demo HIBP report to a lookup table indexing arrays of usernames by breach name.

TO DO — code & explanation

## MAYBE — Another Practical Example — Nobel Prizes by Laureate Name

Another data set we've worked with a lot is the official list of Nobel Prize winners. 

A logical lookup table to build from that dataset would be one that maps laureate names to arrays of dictionaries of years and categories. This would allow us to quickly find the years and categories for Marrie Curie's prizes.

TO DO — code and explanation

## An Optional Challenge

Starting with your solution to the bonus solution to the previous challenge, or, with the sample solution in `pbs164-challengeSolution-Bonus.jq`, update the script to capture the details from every matched breach for every user. For each matching user+breach combination, return a dictionary indexed by:

1. `AccountName`: the user's email account name
2. `BreachId`: the ID of the matching breach
3. `BreachTitle`: the title of the matching breach
4. `BreachedDataClasses`: the list of breached data classes

**Hint:** you'll need to explode the list of breaches for each user while retaining their account name in a variable.

For bonus credit, update the matching logic to check both the breach title and breach ID for a case-insensitive match against the search string. **Hint:** you'll need more parentheses and the `or` operator.

## Final Thoughts

TO DO
