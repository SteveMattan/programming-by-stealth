## PBS 165 of X — jq: Variables

TO DO

## Matching Podcast Episode

TO DO

## Installment Resources

* The instalment ZIP file — [pbs165.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs165.zip) TO CREATE

## PBS 164 Challenge Solution

The challenge set at the end of the previoius instalment was to craete a jq script that finds all users caught in a breach that matches a given search pattern case-insensitively.

This challenge encompassed five key concepts we've covered thus far in the seriues:

1. Converting a lookup-table-style dictionary into an array of entry-type dictionaries with `to_entries`. 
2. The design pattern of exploding an array, processing its contents in some way, and then re-collecting the pieces afterwards using array construction — i.e. code of the form: `[ .[] | … ]`.
3. The use of the two-argument version of `any` within a `select` to filter items that contain an array based on the value of any one elemenmt within the array.
4. The use of `ascii_downcase` on both strings being compared to make the comparison case-insensitive.
5. The use of the `--arg` commandline option to pass a variable into jq.

With all that in mind, you'll find a sample solution in the instalment ZIP as `pbs164-challengeSolution-Basic.jq`:

```jq
# Find users caught up in any breach that matches a given search string.
# Input:    JSON as downloaded from the HIBP service
# Output:   An array of account names (the parts of email addresses to the left of the @).
# Variables:
# - $breachSearch		The string to search breach names by un a case-insensitive way

# transform the lookup of breaches by AccountName into a list of entries:
# - keys will be account names
# - values will be arrays of breach IDs
.Breaches | to_entries

# select only the entries for users caught up in a breach with a matching ID
| [
  # explode the list of entries
  .[]

  # select only the entries for users caught up in the given breach
  | select(any(.value[]; . | ascii_downcase | contains($breachSearch | ascii_downcase)))

  # keep just the account name
  | .key
]
```

To run this script against the demo Have-I-Been-Pwnd domain breach export in the file `hibp-pbs.demo.json`  to find all users caught up in a breach that contains `drop` in its breach ID use the command:

```sh
jq -f ./pbs164-challengeSolution-Basic.jq --arg breachSearch drop hibp-pbs.demo.json
```

This produces the output:

```json
[
  "egreen",
  "mwkelly"
]
```

With the comments removed, there is actually very little code in the script:

```jq
.Breaches | to_entries
| [
	.[]
	| select(any(.value[]; . | ascii_downcase | contains($breachSearch | ascii_downcase)))
  | .key
]
```

For context, the sample breach report used as input looks like this:

```json
{
    "Breaches": {
      "josullivan": [
        "OnlinerSpambot"
      ],
      "egreen": [
        "Dropbox"
      ],
      "mwkelly": [
        "Dropbox",
        "KayoMoe",
        "LinkedIn",
        "LinkedInScrape",
        "PDL"
      ],
      "ahawkins": [
        "iMesh",
        "OnlinerSpambot"
      ],
      "ptraynor": [
        "Collection1"
      ]
    },
    "Pastes": {}
  }  
```

We are only interested in `.Breaches`, which is a lookup-table-style dictionary index by the username part of emails addresses (the bit to the right of the `@`), mapping to arrays of breach IDs in the HIBP database.

We start by converting this lookup table into an array of entries with `to_entries`, where each entry will have a form like:

```json
{
  "key": "mwkelly",
  "value": ["Dropbox","KayoMoe","LinkedIn","LinkedInScrape","PDL"]
}
```

We then need to keep only the entries that contain at least one breach matching the search string. To keep or discard an entire entry we need to use the `select` function with a condition as its only argument. The condition needs to check if any string in the `.value` array matches our string, so to do that we use the two-argument version of the `any` function to evaluate to `true` if any item in our array meets our criteria.

As a reminder, the first argument in the two-argument form of `.any` needs to be a filter that produces one or more value to test, and the second argument is a filter that performs the test. In this case, we need to check every string in the `.value` array, so the first argument is simply that array exploded (`.value[]`).

The second argument needs to be a filter that check the current value being tested (`.`) against the passed searsch string in a case-insensitive way. The key here is to start by converting the current value to lower case by piping it to `ascii_downcase` before piping it to the `contains()` function to check if it contains the lowercased version of our search string (`$breachSearch`).

At this stage, only entries matching our search string remain. We only want the email usernames, which are in the `.key` key of each entry, so we select just that key as the last step within the exploded entries.

All our processing is wrapped in square braches so the remaining email usernames get grouped into an array.

For bonus credit, there was a second challenge, to expand this solution to ignore any breach that does not contain passwords.

The key to this bonus challenge is to use the `--slurpfile` commandline flag to import a downloaded version of the HIBP breach database and use it for data enrichment. You'll find a copy of this database in the file `hibp-breaches-202040329.json` in the installment ZIP.

You'll find a sample solution for bonus credit in the instalment ZIP as `pbs164-challengeSolution-Bonus.jq`:

```jq
# Find users caught up in any breach that leaked passwords that matches a given search string.
# Input:    JSON as downloaded from the HIBP service
# Output:   An array of account names (the parts of email addresses to the left of the @).
# Variables:
# - $breachSearch   The string to search breach names by un a case-insensitive way
# - $breachDetails	An array containing a single entry, the JSON for the
#                   latest lookup table of HIBP breaches indexed by breach
#                   name

# transform the lookup of breaches by AccountName into a list of entries:
# - keys will be account names
# - values will be arrays of breach IDs
.Breaches | to_entries

# filter down to just the users caught up in breaches matching the given search string that leaked passwords
| [
	# explode the list of entries
	.[]

	# select only the entries for users caught up in a breach with a matching ID
	| select(any(.value[];
		# breaches that match the search string
		(. | ascii_downcase | contains($breachSearch | ascii_downcase))

		# breaches with passwords
		and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
	))

	# keep just the account name
  | .key
]
```

We can use this script to find any users caught up in a breach with an ID that contains *'onliner'* that contained passwords with the command:

```sh 
jq -f ./pbs164-challengeSolution-Bonus.jq --slurpfile breachDetails hibp-breaches-202040329.json --arg breachSearch onliner hibp-pbs.demo.json
```

This will return two users caught up in the `OnlinerSpambot` breach which did contain passwords:

```json
[
  "josullivan",
  "ahawkins"
]
```

Notice that this script contains just two change from the basic version.

Firstly, the `--slurpfil` commandline argument is used to pass the database of all breaches to the script as the variable `$breachDetails[0]`. Remember that `--slurpfile` always wraps the contents loaded from the JSON file in an array in case the JSON file contained more than one element. In this case the JSON file contains a dictionary of breach data indexed by Breach ID. For each breach the following keys are defined:

```json
["AddedDate","BreachDate","DataClasses","Description","Domain","IsFabricated","IsMalware","IsRetired","IsSensitive","IsSpamList","IsSubscriptionFree","IsVerified","LogoPath","ModifiedDate","Name","PwnCount","Title"]
```

The one we're intersted in is `DataClasses`, which is an array of strings defining the types of data caugh up in the breach, and for our purposes, we only care that any breach which contained passwords will have a `.DataClasses` array that contains that string `"Passwords"`.

You can see this for yourself by extracting the data classses for the OnlinerSpambot breach with the command:

```sh
jq '.OnlinerSpambot.DataClasses' hibp-breaches-202040329.json
```

This shows that t hat breach contained the following:

```json
[
  "Email addresses",
  "Passwords"
]
```

We can also see that the `PDL` breach that the user `mwkelly` was caught up on does not contain passwords:

```sh
jq '.PDL.DataClasses' hibp-breaches-202040329.json
#[
#  "Email addresses",
#  "Employers",
#  "Geographic locations",
#  "Job titles",
#  "Names",
#  "Phone numbers",
#  "Social media profiles"
#]
```

This lets us verify that the bonus script works as intended. If we use the basic script to search for `pdl` we get one user:

```sh
jq -f ./pbs164-challengeSolution-Basic.jq --arg breachSearch pdl hibp-pbs.demo.json
#[
#  "mwkelly"
#]
```

But if we use th bonus solution we get none:

```sh
jq -f ./pbs164-challengeSolution-Bonus.jq --slurpfile breachDetails hibp-breaches-202040329.json --arg breachSearch pdl hibp-pbs.demo.json
# []
```

Now, let's look at the second change, the part of the script that makes use of the extrenal data file to filter the results — the test within the call to `select`. In the basic version this call was simply:

```jq
| select(any(.value[]; . | ascii_downcase | contains($breachSearch | ascii_downcase)))
```

But in the bonus version there is much more logic embedded within it:

```jq
| select(any(.value[];
  # breaches that match the search string
  (. | ascii_downcase | contains($breachSearch | ascii_downcase))

  # breaches with passwords
  and ($breachDetails[0][.].DataClasses | contains(["Passwords"]))
))
```

The single condition in the basic version has been replaced with two conditions, each grouped within parentheses, and separated from each other by the `and` operator. The first condition is the original one, it's the second condition that's new:

```jq
$breachDetails[0][.].DataClasses | contains(["Passwords"])
```

The first thing to note is that all this is happening inside the call to `any()` which is checking each breach ID in the list of breaches for a user one-by-one, so the value of *the item currently being processed*, i.e. `.` is a breach ID like `"Dropbox"` , `"LinkedIn"`, or `"PDL"`.

This means the details of the breach currently being checked are in `$breachDetails[0][.]`, and the list of data types the breach contained is in `$breachDetails[0][.].DataClasses`.

Remember that when the input and the argument to the `contains` function are both strings it checks if the argument is a sub-string of the input, but when the input and the argument are both arrays, it checks if the input array contains every element in the argument array. We want to check the array of breached data types for the single string `"Passwords"`, so we pipe the entire array of breached data types to the `contains()` function and give it the argument `["Passwords"]`.

## How jq Thinks About Variables

TO DO

## An Optional Challenge

Starting with your solution to the bonus solution to the previous challenge, or, with the sample solution in `pbs164-challengeSolution-Bonus.jq`, update the script to capture the details from every matched breach for every user. For each matching user+breach combination, return a dictionary indexed by:

1. `AccountName`: the user's email account name
2. `BreachId`: the ID of the matching breach
3. `BreachTitle`: the title of the matching breach
4. `BreachedDataClasses`: the list of breached data classes

**Hint:** you'll need to explode the list of breaches for each user while retaining their account name in a variable.

For bonus credit, update the matching logic to check both the breach title and breach ID for a case-insensitive match against the search string. **Hint:** you'll need more parentheses and the `or` operator.

## Final Thoughts

TO DO
