## PBS 159 of X — jq: Manipulating Data

In this instalment we're tackling the final of the three tasks `jq` can help us with — we've already seen how to pretty-print JSON, and how to search JSON, now, we're going to learn how to transform the data we've selected so our outputs can have a different format to our inputs.

TO UPDATE

## Matching Podcast Episode

TO DO

## Mathematical Operators & Functions

Let's start nice and simple, the jq language supports the usual suspects in terms of mathematical operators:

| Operator | Description        | Example                      |
| -------- | ------------------ | ---------------------------- |
| `+`      | Addition           | `jq -n '1 + 1'` produces `2` |
| `-`      | Subtraction        | `jq -n '3 - 1'` produces `2` |
| `*`      | Multiplication     | `jq -n '2 * 1'` produces `2` |
| `/`      | Division           | `jq -n '4 / 2'` produces `2` |
| `%`      | Modulo (remainder) | `jq -n '5 % 3'` produces `2` |

Note the use of the `-n` flag in the examples to tell the `jq` command not to expect any input to process.

Something to notice is that the jq language does not support the increment and decrement operators `++` and `--`.

As well as these operators, the jq language also provides built in functions for performing arithemtic.

To make the examples shorter to write and easier to interpret we'll use a pair of JSON files from the instalment ZIP in our examples. First, we'll use `numbers.json` which contains a single top-level array of numbers:

```json
[
	-42,
	0,
	3.1415,
	11
]
```

And we'll also use `menu.json` which contains a top-level array of dictionaries, each contianing keys that are numeric:

```json
[
	{
		"name": "hotdogs",
		"price": 5.99,
		"stock": 143
	},
	{
		"name": "pancakes",
		"price": 3.10,
		"stock": 43
	},
	{
		"name": "waffles",
		"price": 7.50,
		"stock": 14
	}
]
```

Note that some of these functions can tolerate having non-numbers sent to them, but many will throw errors for at least some non-numeric data types, so to be safe, only send numbers through these functions. Another thing to watch out for is that even when non-numeric values don't cause errors they can produce unexpected results, e.g. the absolute value of a string represatation of a negative number is the same string, un-changed — `jq -n '"-9.999" | abs'` outputs `"-9.999"`.

| jq Function         | Description                                                  | Example                                                      |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `abs`               | Outputs the absolute value of the input.                     | `jq .[]|abs` outputs`42`, `0`, `3.1415` & `11`               |
| `floor`             | Rounds input decimal numbers down to the integer part.       | `jq -n '3.1415 | floor'` outputs `3`, and `jq -n '9.999 | floor'` outputs `9` |
| `sqrt`              | Outputs the square root of the input.                        |                                                              |
| `min`               | Outputs the minimum value from an input array of numbers.    | `jq '. | min' numbers.json` outputs `-42`                    |
| `max`               | Outputs the maximum value from an input array of numbers.    | `jq '. | max' numbers.json` outputs `11`                     |
| `min_by(.KEY_PATH)` | Outputs the dictionary in an input array of dictionaries that has the minimum value for a given key. | `jq -c '. | min_by(.stock)' menu.json` outputs `{"name":"waffles","price":7.50,"stock":14}` |
| `max_by(.KEY_PATH)` | Outputs the dictionary in an inpuit array of dictionaries that has the maximum value for a given key. | `jq -c '. | max_by(.price)' menu.json` outputs `{"name":"waffles","price":7.50,"stock":14}` |

Those are the arithmetic functions provided by the jq language itself, but the `jq` command has a mathematical trick up its sleeve! All the standard 1, 2 & 3 argument C arithmetic functiuons from C's standard math library can be used in jq. 

For reason's I can't quite fathom the way in which one-argument C functions and two or three argument C functions get mapped to jq are not consistent. For one-argument C functions the input to the jq function gets passed as the C function's argument. But, for two and three argument C functions all arguments need to be specified in jq.

The exact functions available will depend on the version of the C libaries installed on the computer, but some widely available useful ones of note are:

| C Maths Function | Description                                                  | Example                                                      |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `ceil`           | Round an input decimal number up to the nearest integer. An obvious companion for jq's built-in `floor` and C's `round` functions. | `jq -n '3.1415 | ceil'` outputs `4`, and `jq -n '9.999 | ceil'` outputs `10` |
| `round`          | Round an input decimal number up or down to the nearest integer. An obvious companion for jq's built-in `floor` and C's `ceil` functions. | `jq -n '3.1415 | round'` outputs `3`, and `jq -n '9.999 | round'` outputs `10` |
| `pow`            | Raise an input number to the power passed as the first argument. | `jq -n '2 | pow(.; 3)'` outputs `8`                          |

## Parsing Strings to Dictionaries with `capture`

Not only does the jq language support standard Perl-Compatible-Regular-Expressions (PCRE), it also supports the named-capture-groups extension to the standard. The built-in `capture` function makes use of this feature to use regular expressions to extract named pieces of data from strings.

In regular PCRE each opening round bracket (`(`) within a regular expression starts a new numbered capture group. With named capture groups you assign a name to each group instead of relying on automatic numbering. The name is specified within angled brackets (`<>`) after a question mark (`?`) at the start of the capture group.

That sounds more complicated than it really is, to capture the hours, minutes, and seconds of a time with capture groups you would use a regular expression like:

```pcre
(?<hours>[0-9]{1,2}):(?<minutes>[0-9]{2}):(?<seconds>[0-9]{2})
```

This RE has three named capture groups with colons between them. The first capture group is named `hours` and matches one or two digits, the second is named `minutes` and matches exactly 2 digits, and the third is named `seconds` and also matches exactly two digits. Remember that the character class `[0-9]` matches a digit, and the cardinality `{1,2}` means *at least one and at most two*, and the cardinarlity `{2}` means exactly two.

The built-in jq function `capture` requires the input be the string to be processed, and the first argument to be a string contianing a regular expression with named capture groups. The output will be a dictionary with key-value pairs for each named capture group in the regular expression. An optional second argument can be passed to specify PCRE flags like `i` for *case-insensitibve* as a single string.

Using our example RE above with jq we can parse times into their components like so:

```sh
jq -n '"9:00:00" | capture("(?<hours>[0-9]{1,2}):(?<minutes>[0-9]{2}):(?<seconds>[0-9]{2})")'
# {
#   "hours": "9",
#   "minutes": "00",
#   "seconds": "00"
# }
```

## Transforming Strings

As well as allowing us to transform numbers, the jq languages provides many mechanisms for transforming strings.

### 'Adding', 'Multipling' & 'dividing' Strings (Operator Overloading)

The jq language has, to use programming jargon *overloaded* some of it's operators, including the addition (`+`) operator. Overloaded operators do different things when presented with different types of data to operate on. Many programming languages use overloading, and while we may not have called it out by name when we expored JavaScript, we did see operator overloading when we used `+` both for arithmetic addition, and for string concatenation.

Note that the jq language's support of operator overloading is basic compared to what we saw with JavaScript. JavaScript's operator overloading can handle different data types on each side of the operator, and them automatically *casts* (i.e. converts) one of the two to match the other before applying the appropriate action. This requires complex rules for determining what to do for every possible combination of types. In jq things are much simpler — with just a few specific exceptions, **the types on each side of the overloaded operators must match**! 

Bringing this back to strings, like in JavaScript, jq's `+` operator is overloaded for both arithmentic addition and string concatenation  i.e. when both inputs are numbers they get added, and when both are strings they get concatenated:

```sh
# two numbers - arithmetic addition (as above)
jq -n '22 + 20' # oputputs 42

# two strings - concatenation
jq -n '"a string" + " another string"' # oputputs "a string another string"

# mismatched types
jq -n '"a string" + 42' # throws an error
```

As we'll learn later, the `+` operator is even more overloaded than this, it can also handle arrays and dictionaries!

The multiplication operator (`*`) is also overloaded, and it is one of those where a specific mis-match of types is explicitly supported — you can multiply a string by a number to concatenate it with itself that many times, in other words, to repeat it that many times:

```sh
jq -n '"Ho" * 3' # outputs "HoHoHo"
```

Finally, the division operator `/` has been overloaded to work with two strings — when a string is divided by another string, the string to the left is split on the string to the right, and an array is returned. In other words, **string division with `/` is an shortcut for the `split` function**.

```sh
jq -nc '"10:20:30" / ":"' # outputs ["10","20","30"]
```

### Built-in String Functions

The jq language provides a selection of built-in functions for manipulating strings, some of the more useful ones are listed below:

| Function         | Description                                                  | Example                                                      |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `ascii_downcase` | Convert an input string to lower case.                       | `jq -n '"Somethin" | ascii_downcase'` outputs `"something"`  |
| `ascii_upcase`   | Convert an input string to upper case.                       | `jq -n '"Something" |ascii_upcase'` outputs `"SOMETHING"`    |
| `ltrimstr`       | Remove a given prefix from an input string, or return the string un-changed if the prefix is not present. | `jq -n '"DEBUG: something" | ltrimstr("DEBUG: ")'` outputs `"something"` |
| `rtrimstr`       | Remove a given postfix from an input string, or return the string un-changed if the postfix is not present. | `jq -n '"something (DEBUG)" | rtrimstr(" (DEBUG)")'` outputs `"something"` |
| `sub`            | Perform string substitution on an input string to produce the output string. A regular expression should be passed as the first argument, a replacement as the second, and optionally regular expression flags as a third. | `jq -n '"2023-11-12: Something" | sub("[0-9]{4}-[0-9]{2}-[0-9]{2}: "; "")'` outputs `"Something"`, i.e. replaces a leading timestamp with an empty string. |

### Formatting & Escaping Values with `@`

When using the `jq` command to prepare strings for use in other applications you may need to escape or encode the strings in some way, and the jq language offers built-in support for many popular string escape formats, and data encoding formats.

The syntax for applying an encoding is to use the name of a supported encoding pre-fixed with an `@` symbol as filter. Different encoding support different input types, but all will output strings.

The `@text` and `@json` encodings support all input types, and output plain text and JSON respectively. Note that the `@text` encoding is equivalent to the `tostring` function.

The `@csv` and `@tsv` formats reqire arrays as inputs, and will produce strings in *coma-separated value*  and *tab-separated value* formats respectivesly. An important subtly to remember when using tese two format filters is that the `jq` command defaults to JSON-encoding all its outputs, so you need to remember to disable that default behaviour with the `-r` (`--raw-output`) flag we learned about at the start of this mini-series.

```sh
# build a one-line CSV file
echo '["pancakes", "waffles", "popcorn"]' | jq -r '@csv' | test.csv

# build a one-line TSV file
echo '["pancakes", "waffles", "popcorn"]' | jq -r '@rsv' | test.rsv
```

The string escaping formats require strings as inputs, and the following formats are supported:

| Encoding   | Description                                                  | Examples                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `@html`    | Apply HTML escape sequences to the special characters in the input string. | `echo '"this & that"' | jq '@html'` outputs `"this &amp; that"` |
| `@uri`     | Apply URL/URI percent-encodings to the special characters in the input string. | `echo '"this & that"' | jq '@uri'` outputs `"this%20%26%20that"` |
| `@base64`  | Apply Base64 encoding to the input string.                   | `echo '"this & that"' | jq '@base64'` outputs `"dGhpcyAmIHRoYXQ="` |
| `@base64d` | Apply Base64 decoding to the input string.                   | `echo '"dGhpcyAmIHRoYXQ="' |jq '@base64d'` outputs `"this & that"` |
| `@sh`      | Apply POSIX Shell string escaping to the input string. It's important to **use raw output** with this format filter, i.e. use `jq -r`. | `echo '"this & that"'  | jq -r '@sh'` outputs `'this & that'` |

## Converting Between Strings & Arrays with `split` & `join`

Some jq fuctions only accept arrays or strings, and some always output arrays or strings, and sometimes those requirements don't line up with the inputs you need to send to the `jq` command for processing, or, that you need out of the `jq` command for further use. In those situations it can be very helpful to convert strings with some kind of separator into arrays, or arrays into strings with some kind of separator, and as their names suggest, that's what the built-in `split` & `join` functions do.

`split` requires a string as the input and a string representing the characters to split on as the first argument, and returns an array. For example:

```sh
jq -n '"1,2,3" | split(",")'
# [
#   "1",
#   "2",
#   "3"
# ]
```

`join` is effectively the inverse and requires an array as the input, a separator string to place between the array elements as the first argument, and returns a string. For example:

```sh
echo '[1, 2, 3]' | jq 'join(",")'
# "1,2,3"
```

As well as splitting on a string separator, jq can also split on a regular expression. When the `split` function receives just one argument it's interpreted as a string, but when it recieves two the first is interpreted as a regular expression, and the second as PCRE flags. This means that **when you don't need PCRE flags but you do need a regular expression you have to remember to pass an empty string as a second argument**. 

As a quick example we can split on a coma followed by an optional space by using the regular expression `[ ]?` with the two-argument form of the `split` function:

```sh
jq -n '"1,2,3" | split(",[ ]?"; "")'
# [
#   "1",
#   "2",
#   "3"
# ]
jq -n '"1, 2, 3" | split(",[ ]?"; "")'
# [
#   "1",
#   "2",
#   "3"
# ]
```

## Altering Arrays

Now that we've seen how to alter strings, let's take a look at way of transforming arrays.

### Re-Ordering Arrays (`sort` & `reverse`)

Let's start with the simplest type of array transformation — re-orderings.

The simplest re-ordering is a straight forward reversing, and jq provides just that with the `reverse` function:

```sh
jq -nc '[1, 2, 3] | reverse' # outputs [3,2,1]
```

Then of course we have array sorting.

When you have an array with simple values the built-in `sort` function will generally do what you want.

The function requires an array as input, and it will first group elements by type, starting with any `null` elements, then any booleans, then numbers, then strings, then arrays, and finally dictionaries. Within each grouping it will then perform the most sensible sorting, `false` before `true` for Booleans, numeric sorting for numbers, and alphabetic (lexical) sorting for strings. (Note that the rules for sorting arrays and dictionaries exist, but are out of the scope of this series).

Let's see the `sort` function in action:

```sh
# numbers
jq -nc '[1, 4, 3] | sort' # outputs [1,3,4]

# strings
jq -nc '["popcorn", "waffles",  "pancakes"] | sort' 
# outputs ["pancakes","popcorn","waffles"]

# mixed types
jq -nc '[42, true, 11, "waffles", false,  "pancakes"] | sort'
# outputs [false,true,11,42,"pancakes","waffles"]
```

When dealing with arrays containing more complicated elements like other arrays or dictionaries, you probably want to specify your own rule for sorting, you can do this with th `sort_by` function. It takes as an argument a filter, and that filter will be applied to each array element, and the elements will be sorted based on the results of applying the filter. Usually the filter is simply a dictionary key.

For example, we can re-order our menu (from the `menu.js` file in the instalment ZIP), with:

```sh
jq 'sort_by(.price)' menu.json
```

This outputs:

```json
[
  {
    "name": "pancakes",
    "price": 3.10,
    "stock": 43
  },
  {
    "name": "hotdogs",
    "price": 5.99,
    "stock": 143
  },
  {
    "name": "waffles",
    "price": 7.50,
    "stock": 14
  }
]
```

As you can see, the array is now sorted by price.

### Adding and Removing Elements with the  `+` & `-` Operators

As mentioned earlier, the `+` operator has been overloaded to perform a useful action when both inputs are arrays — it merges them into a new bigger array:

```sh
# Note: -n for no input & -c for compact output
jq -nc '[1, 2] + [3, 4]' # outputs [1,2,3,4]
```

While the `-` operator is not overloaded for strings, it is overloaded for arrays, and can be used create a new array with elements removed. The array to the left of the `-` is treated as the original array, and the elements in the array to the right of the `-` are removed from the original array, if present, to create the output array.

```sh
jq -nc '[1, 2, 3, 4] - [4, 5]' # outputs [1,2,3]
```

### Array Deduplication

When you start adding arrays together it's easy to end up with duplucates that you may well not want. The jq language provides two useful functions for removing them.

Firstly, the simple `unique` function returns the input array sorted with any duplicated elements removed. The input must be an array. For exmaple:

```sh
jq -nc '[4, 1, 4, 3, 2] | unique' # outputs [1,2,3,4]
```

If you need a more complex definition of 'uniqueness' you can use the `unique_by` function to supply your own filter as an argument. The output array will only contain one element which the filter evaluates to a given value. If multiple elements evaluate to the same value, one will be kept, but there's no guarantee as to which one it will be. Also note that the elements in the output array will be sorted based on the result of the filter.

As a somewhat contrived example, we can make our menu (from `menu.json` above) unique by length of name. Before we do, let's compute the lengths see what results we expect, we can do that with:

```sh
jq '.[] | .name | length' menu.json
```

This shows that hotdogs and waffles have 7 letters, and pancakes 8. We would expect to always get pancakes in our answer, but only one of waffles or hotdogs when we make the menu unique by name. Let's try:

```sh
jq 'unique_by(.name | length)' menu.json
```

This gives us the output:

```json
[
  {
    "name": "hotdogs",
    "price": 5.99,
    "stock": 143
  },
  {
    "name": "pancakes",
    "price": 3.10,
    "stock": 43
  }
]
```

As expected, we get one item with a name of length 7, the one with a name of length 8, because the items are sorted on the result of the filter as well as deduplicated based on it.

### Flattening Nested Arrays

When assembling an array from multiple sources you may end up with an array of arrays when you actually wanted a single unified array. This is where the built-in `flatten` function comes in.

The `flatten` function takes an array as in input, and if it contains other arrays, it replaces them with their entries in the output array. The funtion applies this logic recursively, so you if your array contains arrays which contain arrays, it will still flatten them all out to a single array of all the values.

```sh
jq -nc '[1, [2, 3], [4, [5, 6]]] | flatten'
# outputs [1,2,3,4,5,6]
```

By default the flatten function will keep recursing down into all nested arrays, but you can pass an optional argument to limit how deep it goes. To see what this means, let's repeat our above example with limits of 2 and 1:

```sh
# limit to a depth of 2
# arrays in the input array, and arrays in arrays in the input array
jq -nc '[1, [2, 3], [4, [5, 6]]] | flatten(2)'
# outputs [1,2,3,4,5,6]

# limit to a depth of 1
# arrays in the input array only
jq -nc '[1, [2, 3], [4, [5, 6]]] | flatten(1)'
# outputs [1,2,3,4,[5,6]]
```

### The `map` Function

After `select`, the most powerful function in `jq` is probably `map`. It takes an array as an input, and a filter as an argument, and it returns a new array containing the result of applying the filter to each element of the input array. In effect, it lets you **loop over an aray in a single function call**, and **process each element without exploding the array**.

Fo example, we can convert all the numbers in an array to their absolute values with:

```sh
jq -nc '[1, -2, 3, -42] | map(. | abs)'
# outputs [1,2,3,42]
```

Note that, like with the `select` function, the special `.` symbol means *'the current value being processed'*. That means that when processing the first element in the input array in the example above `.` is `1`, then it's `-2`, and so on.

## Dictionary Manipulation

### Adding and Removing Keys

As mentioned earlier, the `+` operators is overloaded for handling dicrtionaries. When two dictionaries are added together, a new dictionary is created containing the keys and values from both. If both input dictionaries define a value for the same key, the value from the dictionary on the right of the `+` operator is used.

If the dictionaries contain dictionaries, a recursive merge can be done by using the `*` operator instead of the `+` operator.

You might imagine key could comehow be removed with an overloaded subtraction operator, but alas not, we need to use the built-in `del` function for that. This function requires a dictionary as the input, and a key path as an argument. For example, we could remove the stock key from each item in our menu (`menu.js` from the instalment ZIP) with:

```sh
jq '.[] | del(.stock)' menu.json
```

Which returns:

```json
{
  "name": "hotdogs",
  "price": 5.99
}
{
  "name": "pancakes",
  "price": 3.10
}
{
  "name": "waffles",
  "price": 7.50
}
```

Note we expoloded the array in this example, so we now have a list of separate output values instead of a single array. We can combin the `del` function with the `map` function to avoid exploding the array:

```sh
jq 'map(del(.stock))' menu.json
```

This returns a single array containing the updated dictionaries:

```json
[
  {
    "name": "hotdogs",
    "price": 5.99
  },
  {
    "name": "pancakes",
    "price": 3.10
  },
  {
    "name": "waffles",
    "price": 7.50
  }
]
```

## DEFINITE BREAK — Constructing new Outputs

So far in the series we've learned to filter output down from a super-set to a sub-set, and to apply transformations to the output, but we're now realy for the jq language's final conceptual leap — building our own strings, arrays, and dictionaries to produce truly besoke outputs based on our inputs.

We'll start simple, by building our own strings, and then we'll move on to building our own arrays and dictionaries.

## Building New Strings Containing Values with String Interpolation

When working with JavaScript we learned that we could use so-called *template strings* to build strings that contained both directly specified characters, and, values read from variables. This type of string construction is known as *string interpolation*, and the jq language supports it with a somewhat odd escape sequence inside strings.

We've already seen that we can use double quotes to create simple strings within our filters. Those strings support the standard espcae sequences you would expect from our experience with JavaScript and Bash like `\"` to include a double-quote within a string, `\n` for a new line character, `\t` for a tab character, and so on. 

The jq lanaguge adds a non-standard escape sequence for injecting the result of a filter into a string — `\()`. The filter who's value will be injected is added between the parentheses.

For example, using our Nobel Prizes data set we can use our existing searching experience to find the laureats dictionary for friendo of the NosillaCast podcast Dr. Andres Ghez, and then use string interpolation to build a nice human-friendly description of her citation:

```bash
# the -r flag to output the text directly instead of as a JSON string
jq -r '.prizes[] | .laureates[]? | select(.surname == "Ghez") | "\(.firstname) \(.surname) was awarded her prize for \(.motivation)"' NobelPrizes.json
```

This outputs the text:

> Andrea Ghez was awarded her prize for "for the discovery of a supermassive compact object at the centre of our galaxy"

Breaking the example down, the first few filters in the jq pipeline select out just Andrea's entry in the `laureats` array in the prize that contains her as a laureat.

```jq
.prizes[] | .laureates[]? | select(.surname == "Ghez")
```

If we run the command with just this much of the filter chain we can see the dictionary that acts as the input to the final filter in the chain, the one that creates a new string using string interpolation:

```sh
# no -r flag since we want pretty-printed JSON output
jq '.prizes[] | .laureates[]? | select(.surname == "Ghez")' NobelPrizes.json
```

This produces the dictionary:

```json
{
  "id": "990",
  "firstname": "Andrea",
  "surname": "Ghez",
  "motivation": "\"for the discovery of a supermassive compact object at the centre of our galaxy\"",
  "share": "4"
}
```

Now, let's look at the final filter, the one that builds the output string using interpolation:

```jq
"\(.firstname) \(.surname) was awarded her prize for \(.motivation)"
```

You can see the filter contains a single string definition, and that string definition contains three inserted values because there are three `\()` escapes — `\(.firstname)` to inject Andrea's first name from the input to the filter (i.e. the dictionary above), `\(.surname)` to inject Andrea's surname, and `\(.motivation)` to inject the reason she won the prize.

## Array Construction

In our various examples we've already seen that we can create arrays containing basic values by wrapping those values in square brackets (`[]`). This same syntax can actually be used to add the results of executing filters to an array by simply including a filter as an array element. If a filter wrapped in square brackets produces multiple values, each value returned by the filter will become an element in the constructed array.

The most common use for wrapping filters in square brackets is to re-combine exploded arrays back into a single array.

If we go back to our Nobel Prizes data set, we know that we can explode the top-level array of prizes with `.prizes[]`. We also know we can filter those exploded values down using the  `select` function, for example, we can get all prizes awarded after 2020 with:

```sh
jq '.prizes[] | select((.year | tonumber) > 2020)' NobelPrizes.json
```

This will produce a list of many individual dictionaries as outputs — **note there is no opening square brace at the top of the output, and no comas separating each dictionary**. If we want to combine all those separate outputs back into a single array, we can wrap the entire jq filter with square braces:

```sh
jq '[.prizes[] | select((.year | tonumber) > 2020)]' NobelPrizes.json
```

This time, **note that there are opening and closing square braces at the top and bottom of the output, and, that each dictionary is now separted from the next with a coma**. In other words, we now have one single output that is an array of dictionaries.

## Dictionary Construction

Finally, the `jq` command is ofte used to process some input JSON data structure into a new output JSON data structure for further processing somewhere else. To do this effectively we need to be able to construct custom dictionaries with just the keys of our choosing, and values we have computed.

The syntax to construct dictionaries in jq is verlike the syntax for construction dictionaries in JavaScript — the entire dictionary is wrapped in curly braces (`{}`), and keys and values are separated by colons (`:`). Like in JavaScript, and un-line in JSON, key names don't need to be quoted unless they contain spaces or special characters. Finally, the values can be literal values, or, filters. If a value is specified with a filter, the filter will be executed, and the resuting value stored.

As an example, let's use the `jq` command to process the Nobel Prizes data set to produce a single dictionary describing Dr. Andre's nobel prize. Let's start simple and build the command to output a dictionary with just the year and the category.

Based on our previous experience we know we can use the jq filter chain below to extract just the dictionary describing the prize Andread won:

```jq
.prizes[] | select(any(.laureates[]?; .surname == "Ghez"))
```

Let's use the following `jq` command to view the dictionary this filter chain produces:

```json
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez"))' NobelPrizes.json
```

Here's the resulting dictionary:

```json
{
  "year": "2020",
  "category": "physics",
  "laureates": [
    {
      "id": "988",
      "firstname": "Roger",
      "surname": "Penrose",
      "motivation": "\"for the discovery that black hole formation is a robust prediction of the general theory of relativity\"",
      "share": "2"
    },
    {
      "id": "989",
      "firstname": "Reinhard",
      "surname": "Genzel",
      "motivation": "\"for the discovery of a supermassive compact object at the centre of our galaxy\"",
      "share": "4"
    },
    {
      "id": "990",
      "firstname": "Andrea",
      "surname": "Ghez",
      "motivation": "\"for the discovery of a supermassive compact object at the centre of our galaxy\"",
      "share": "4"
    }
  ]
}
```

We can see that the two peices of information we're initially interested in are contained in this dictionary, so we can build a custom dictionary by piping that dictionary to the following jq filter:

```jq
{year: .year, prize: .category}
```

Note that we are defining a new dictionary with two keys, `year`, and `prize`. The value for each key is specified as a very simple filter — a key path.

We can add this filter to the filter chain in our `jq` command like so:

```sh
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year, prize: .category}' NobelPrizes.json
```

This will produce the following dictionary:

```json
{
  "year": "2020",
  "prize": "physics"
}
```

Note that this dictionary is wrongly storing the year as a string, let's fix that by improving the filter we used to look up the value for the `year` key:

```sh
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year | tonumber, prize: .category}' NobelPrizes.json
```

Now we get the more correct dictionary:

```json
{
  "year": 2020,
  "prize": "physics"
}
```

Now, let's expand the dictionary we are building to include Andrea's name and the motivation for her prize.

LEFT OFF HERE!!!

Get the details of Dr. Andrea Ghez's Nobel prize as a new dictionary:

```bash


# Complex example — combine top-level and lower-level data, use string interpolation, and use string substitution
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year | tonumber, prize: .category, name: (.laureates[] | select(.surname == "Ghez") | "\(.firstname) \(.surname)"), citation: (.laureates[] | select(.surname == "Ghez") | .motivation | sub("\""; ""; "g"))}' NobelPrizes.json
# {
#  "year": "2020",
#  "prize": "physics",
#  "name": "Andrea Ghez",
#  "citation": "for the discovery of a supermassive compact object at the centre of our galaxy"
#}
```

## EPISODE BREAK — JQ as a Programming Language

## Defining Variables

Potential example — prizes with and above average number of winners

## Debugging

## External Files

## Variables

## Conditionals

## Loops

