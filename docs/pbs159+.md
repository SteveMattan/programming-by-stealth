## PBS 159 of X — jq: Manipulating Data

In this instalment we're tackling the final of the three tasks `jq` can help us with — we've already seen how to pretty-print JSON, and how to search JSON, now, we're going to learn how to transform the data we've selected so our outputs can have a different format to our inputs.

TO UPDATE

## Matching Podcast Episode

TO DO

## Mathematical Operators & Functions

Let's start nice and simple, the jq language supports the usual suspects in terms of mathematical operators:

| Operator | Description        | Example                      |
| -------- | ------------------ | ---------------------------- |
| `+`      | Addition           | `jq -n '1 + 1'` produces `2` |
| `-`      | Subtraction        | `jq -n '3 - 1'` produces `2` |
| `*`      | Multiplication     | `jq -n '2 * 1'` produces `2` |
| `/`      | Division           | `jq -n '4 / 2'` produces `2` |
| `%`      | Modulo (remainder) | `jq -n '5 % 3'` produces `2` |

Note the use of the `-n` flag in the examples to tell the `jq` command not to expect any input to process.

Something to notice is that the jq language does not support the increment and decrement operators `++` and `--`.

As well as these operators, the jq language also provides built in functions for performing arithemtic.

To make the examples shorter to write and easier to interpret we'll use a pair of JSON files from the instalment ZIP in our examples. First, we'll use `numbers.json` which contains a single top-level array of numbers:

```json
[
	-42,
	0,
	3.1415,
	11
]
```

And we'll also use `menu.json` which contains a top-level array of dictionaries, each contianing keys that are numeric:

```json
[
	{
		"name": "hotdogs",
		"price": 5.99,
		"stock": 143
	},
	{
		"name": "pancakes",
		"price": 3.10,
		"stock": 43
	},
	{
		"name": "waffles",
		"price": 7.50,
		"stock": 14
	}
]
```

Note that some of these functions can tolerate having non-numbers sent to them, but many will throw errors for at least some non-numeric data types, so to be safe, only send numbers through these functions. Another thing to watch out for is that even when non-numeric values don't cause errors they can produce unexpected results, e.g. the absolute value of a string represatation of a negative number is the same string, un-changed — `jq -n '"-9.999" | abs'` outputs `"-9.999"`.

| jq Function         | Description                                                  | Example                                                      |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `abs`               | Outputs the absolute value of the input.                     | `jq .[]|abs` outputs`42`, `0`, `3.1415` & `11`               |
| `floor`             | Rounds input decimal numbers down to the integer part.       | `jq -n '3.1415 | floor'` outputs `3`, and `jq -n '9.999 | floor'` outputs `9` |
| `sqrt`              | Outputs the square root of the input.                        |                                                              |
| `min`               | Outputs the minimum value from an input array of numbers.    | `jq '. | min' numbers.json` outputs `-42`                    |
| `max`               | Outputs the maximum value from an input array of numbers.    | `jq '. | max' numbers.json` outputs `11`                     |
| `min_by(.KEY_PATH)` | Outputs the dictionary in an input array of dictionaries that has the minimum value for a given key. | `jq -c '. | min_by(.stock)' menu.json` outputs `{"name":"waffles","price":7.50,"stock":14}` |
| `max_by(.KEY_PATH)` | Outputs the dictionary in an inpuit array of dictionaries that has the maximum value for a given key. | `jq -c '. | max_by(.price)' menu.json` outputs `{"name":"waffles","price":7.50,"stock":14}` |

Those are the arithmetic functions provided by the jq language itself, but the `jq` command has a mathematical trick up its sleeve! All the standard 1, 2 & 3 argument C arithmetic functiuons from C's standard math library can be used in jq. 

For reason's I can't quite fathom the way in which one-argument C functions and two or three argument C functions get mapped to jq are not consistent. For one-argument C functions the input to the jq function gets passed as the C function's argument. But, for two and three argument C functions all arguments need to be specified in jq.

The exact functions available will depend on the version of the C libaries installed on the computer, but some widely available useful ones of note are:

| C Maths Function | Description                                                  | Example                                                      |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `ceil`           | Round an input decimal number up to the nearest integer. An obvious companion for jq's built-in `floor` and C's `round` functions. | `jq -n '3.1415 | ceil'` outputs `4`, and `jq -n '9.999 | ceil'` outputs `10` |
| `round`          | Round an input decimal number up or down to the nearest integer. An obvious companion for jq's built-in `floor` and C's `ceil` functions. | `jq -n '3.1415 | round'` outputs `3`, and `jq -n '9.999 | round'` outputs `10` |
| `pow`            | Raise an input number to the power passed as the first argument. | `jq -n '2 | pow(.; 3)'` outputs `8`                          |

## String Parsing with `capture`

TO DO

## String Manipulation

The jq language provides a selection of built-in functions for manipulating strings, some of the more useful ones are listed below:

| Function         | Description                                                  | Example                                                      |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `ascii_downcase` | Convert an input string to lower case.                       | `jq -n '"Somethin" | ascii_downcase'` outputs `"something"`  |
| `ascii_upcase`   | Convert an input string to upper case.                       | `jq -n '"Something" |ascii_upcase'` outputs `"SOMETHING"`    |
| `ltrimstr`       | Remove a given prefix from an input string, or return the string un-changed if the prefix is not present. | `jq -n '"DEBUG: something" | ltrimstr("DEBUG: ")'` outputs `"something"` |
| `rtrimstr`       | Remove a given postfix from an input string, or return the string un-changed if the postfix is not present. | `jq -n '"something (DEBUG)" | rtrimstr(" (DEBUG)")'` outputs `"something"` |
| `sub`            | Perform string substitution on an input string to produce the output string. A regular expression should be passed as the first argument, a replacement as the second, and optionally regular expression flags as a third. | `jq -n '"2023-11-12: Something" | sub("[0-9]{4}-[0-9]{2}-[0-9]{2}: "; "")'` outputs `"Something"`, i.e. replaces a leading timestamp with an empty string. |

### Formatting & Escaping with `@`

When using the `jq` command to prepare strings for use in other applications you may need to escape or encode the strings in some way, and the jq language offers built-in support for many popular string escape formats, and data encoding formats.

The syntax for applying an encoding is to use the name of a supported encoding pre-fixed with an `@` symbol as filter. Different encoding support different input types, but all will output strings.

The `@text` and `@json` encodings support all input types, and output plain text and JSON respectively. Note that the `@text` encoding is equivalent to the `tostring` function.

The `@csv` and `@tsv` formats reqire arrays as inputs, and will produce strings in *coma-separated value*  and *tab-separated value* formats respectivesly. An important subtly to remember when using tese two format filters is that the `jq` command defaults to JSON-encoding all its outputs, so you need to remember to disable that default behaviour with the `-r` (`--raw-output`) flag we learned about at the start of this mini-series.

```sh
# build a one-line CSV file
echo '["pancakes", "waffles", "popcorn"]' | jq -r '@csv' | test.csv

# build a one-line TSV file
echo '["pancakes", "waffles", "popcorn"]' | jq -r '@rsv' | test.rsv
```

The string escaping formats require strings as inputs, and the following formats are supported:

| Encoding   | Description                                                  | Examples                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `@html`    | Apply HTML escape sequences to the special characters in the input string. | `echo '"this & that"' | jq '@html'` outputs `"this &amp; that"` |
| `@uri`     | Apply URL/URI percent-encodings to the special characters in the input string. | `echo '"this & that"' | jq '@uri'` outputs `"this%20%26%20that"` |
| `@base64`  | Apply Base64 encoding to the input string.                   | `echo '"this & that"' | jq '@base64'` outputs `"dGhpcyAmIHRoYXQ="` |
| `@base64d` | Apply Base64 decoding to the input string.                   | `echo '"dGhpcyAmIHRoYXQ="' |jq '@base64d'` outputs `"this & that"` |
| `@sh`      | Apply POSIX Shell string escaping to the input string. It's important to **use raw output** with this format filter, i.e. use `jq -r`. | `echo '"this & that"'  | jq -r '@sh'` outputs `'this & that'` |

### ## Converting Between Strings & Arrays with `split` & `join`

## Array Manipulation

### Addition & Subtraction

### Re-Ordering (`sort` & `reverse`)

### Deduplication (`unique` & `unique_by`)

### Flattening with `flatten`

### The `map` Function

## Dictionary Manipulation

### Addition & Subtraction

### The `del` Function

## Constructing new Outputs

### String Interpolation

Build a string describing Andrea Ghez's prize:

```bash
jq '.prizes[] | .laureates[]? | select(.surname == "Ghez") | "\(.firstname) \(.surname) was awarded her prize for \(.motivation)"' NobelPrizes.json --raw-output
# Andrea Ghez was awarded her prize for "for the discovery of a supermassive compact object at the centre of our galaxy"
```

### Array Construction

Most common use is to re-combine multiple outputs from a filter into a single array for final output or to pipe to the next filter in the chain.

Often used as a syntactically shorter alternative to the `map` function.

### Dictionary Construction

Get the details of Dr. Andrea Ghez's Nobel prize as a new dictionary:

```bash
# Basic example — just extract top-level values
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year, prize: .category}' NobelPrizes.json
# {
#  "year": "2020",
#  "prize": "physics"
# }

# Complex example — combine top-level and lower-level data, use string interpolation, and use string substitution
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year, prize: .category, name: (.laureates[] | select(.surname == "Ghez") | "\(.firstname) \(.surname)"), citation: (.laureates[] | select(.surname == "Ghez") | .motivation | sub("\""; ""; "g"))}' NobelPrizes.json
# {
#  "year": "2020",
#  "prize": "physics",
#  "name": "Andrea Ghez",
#  "citation": "for the discovery of a supermassive compact object at the centre of our galaxy"
#}
```

## EPISODE BREAK — JQ as a Programming Language

## Defining Variables

Potential example — prizes with and above average number of winners

## Debugging

## External Files

## Variables

## Conditionals

## Loops

