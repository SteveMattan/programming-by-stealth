# PBS 151 of X â€” Bash: Printf and More

In the previous instalment we dug deep into how Bash interacts with the three standard POSIX data streams (`/dev/stdin`, `/dev/stdout` & `/dev/stderr`), and we finished with a look at the special file `/dev/tty` which provides access to the terminal our script is running in, regardless of where the three standard streams have been redirected to. The plan for this instalment was to re-visit scope, and to look at better string outputs with `printf` rather than `echo`, but thanks to some excellent feedback from listener Jill of Kent (her choice of title), we'll post-pone scope until the next instalment, and start this instalment with an excellent tip related to the `[[` builtin and `/dev/tty`.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file â€” [pbs151.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs151.zip)


## PBS 150 Challenge Solution

The challenge set at the end of the previous instalment was to update the menu script we've been working on for the previous few challenges to ensure all user interaction is via the terminal, even when standard in or standard out are redirected, and to allow the user control the source of the menu based on the following simple rules:

1. by default, the menu will be read from `menu.txt` in the same folder as the script.
2. The menu can be read from standard in with the option `-m -`.
3. The menu can be read from any file with the option `-m FILE`.

To simplify things, there was the option to remove the snark (`-s`) flag.

I chose to remove the `-s` flag to minimise the distractions in my sample solution. You'll find my full solution in the instalment ZIP as `pbs150-challengeSolution.sh`.

The first thing I want to draw your attention to is the use of redirects to and from `/dev/tty` to force the user interaction via the terminal. I added `>/dev/tty` after all echo statements related the accepting the order, and I added both a `>/dev/tty` and `</dev/tty` to the end of the `select` statement so it both writes to the terminal and reads from the keyboard no matter where standard in and out have been redirected:

```bash
# present the menu, with a done option
if [[ -z $limit ]]
then
    echo 'Choose your breakfast (as many items as you like)' >/dev/tty
else
    echo "Choose up to $limit breakfast items" >/dev/tty
fi
select item in done "${menu[@]}"
do
    # skip invalid selections ($item is empty)
    [[ -z $item ]] && continue

    # exit if done
    [[ $item == done ]] && break

    # store and print the item
    order+=("$item")
    echo "Added $item to your order" >/dev/tty

    # if we're limiting, check the limit
    if [[ -n $limit ]]
    then
        [[ ${#order[@]} -ge $limit ]] && break
    fi
done </dev/tty >/dev/tty
```

Finally, lets look at how I chose to initialise the menu.

To avoid code duplication, or, to avoid adding a lot of inline logic to the end of the `while` loop for processing the menu I chose to break the task into two parts:

1. slurp the raw menu into a string
2. process the raw menu line-by-line to built up the array of options

Looking at the first part, I chose to initialise the menu source to the default, then use a simple `if` statement to read from standard in or a file:

```bash
# initialise the options to their default values
# â€¦
menuSource=$(dirname "$BASH_SOURCE")/menu.txt # menu.txt in script dir

# â€¦

# slurp the menu into a string
menuString=''
if [[ $menuSource == '-' ]]
then
    menuString=$(cat)
else
    menuString=$(cat "$menuSource")
fi
```

With the menu loaded into a string named `$menuString`, I then loop through it line-by-line using a here string (`<<<`). As a reminder, this operator redirects the contents of a variable to standard in:

```bash
# process the menu
declare -a menu
while read -r menuLine
do
    # skip comment lines
    echo "$menuLine" | egrep -q '^[ ]*#' && continue

    # skip empty lines
    echo "$menuLine" | egrep -q '^[ ]*$' && continue

    # store the menu item
    menu+=("$menuLine")
done <<<"$menuString"
```

The logic inside the loop is un-changed from the previous version of the script.

The only other change was updating `getopts` to remove support for the `-s` flag, and add the `-m` optional argument.

We can verify that a menu can be loaded from an alternative file by using the `-m`  optional argument to load the menu from the file `menu-montyPython.txt` which offers just one choice, `spam` ðŸ˜‰:

```bash
./pbs150-challengeSolution.sh -m menu-montyPython.txt
```

We can verify the correct handling of redirecting both standard out and standard in with the command:

```bash
echo -e "bacon\neggs\ntoast" | ./pbs150-challengeSolution.sh -m - > order.txt
```

This command redirects standard out and standard in, but the menu is still presented in the terminal, and the keyboard can still be used to enter the options. Finally, the chosen items are correctly written to `order.txt`, which you can verify with:

```bash
cat ./order.txt
```

## Followup â€” Detecting Terminals with `[[` & `-t`

BE SURE TO CREDIT "Listener Jill of Kent"

https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Bash-Conditional-Expressions

```bash
#!/usr/bin/env bash

[[ -t 0 ]] && echo 'STDIN is a terminal' >/dev/tty
[[ -t 1 ]] && echo 'STDOUT is a terminal' >/dev/tty
[[ -t 2 ]] && echo 'STDERR is a terminal' >/dev/tty
```

## Final Thoughts

TO DO

### An Optional Challenge

TO DO