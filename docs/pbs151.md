# PBS 151 of X â€” Bash: Printf and More

In the previous instalment we dug deep into how Bash interacts with the three standard POSIX data streams (`/dev/stdin`, `/dev/stdout` & `/dev/stderr`), and we finished with a look at the special file `/dev/tty` which provides access to the terminal our script is running in, regardless of where the three standard streams have been redirected to. The plan for this instalment was to re-visit scope, and to look at better string outputs with `printf` rather than `echo`, but thanks to some excellent feedback from listener Jill of Kent (her choice of title), we'll post-pone scope until the next instalment, and start this instalment with an excellent tip related to the `[[` builtin and `/dev/tty`.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file â€” [pbs151.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs151.zip)


## PBS 150 Challenge Solution

The challenge set at the end of the previous instalment was to update the menu script we've been working on for the previous few challenges to ensure all user interaction is via the terminal, even when standard in or standard out are redirected, and to allow the user control the source of the menu based on the following simple rules:

1. by default, the menu will be read from `menu.txt` in the same folder as the script.
2. The menu can be read from standard in with the option `-m -`.
3. The menu can be read from any file with the option `-m FILE`.

To simplify things, there was the option to remove the snark (`-s`) flag.

I chose to remove the `-s` flag to minimise the distractions in my sample solution. You'll find my full solution in the instalment ZIP as `pbs150-challengeSolution.sh`.

The first thing I want to draw your attention to is the use of redirects to and from `/dev/tty` to force the user interaction via the terminal. I added `>/dev/tty` after all echo statements related the accepting the order, and I added both a `>/dev/tty` and `</dev/tty` to the end of the `select` statement so it both writes to the terminal and reads from the keyboard no matter where standard in and out have been redirected:

```bash
# present the menu, with a done option
if [[ -z $limit ]]
then
    echo 'Choose your breakfast (as many items as you like)' >/dev/tty
else
    echo "Choose up to $limit breakfast items" >/dev/tty
fi
select item in done "${menu[@]}"
do
    # skip invalid selections ($item is empty)
    [[ -z $item ]] && continue

    # exit if done
    [[ $item == done ]] && break

    # store and print the item
    order+=("$item")
    echo "Added $item to your order" >/dev/tty

    # if we're limiting, check the limit
    if [[ -n $limit ]]
    then
        [[ ${#order[@]} -ge $limit ]] && break
    fi
done </dev/tty >/dev/tty
```

Finally, lets look at how I chose to initialise the menu.

To avoid code duplication, or, to avoid adding a lot of inline logic to the end of the `while` loop for processing the menu I chose to break the task into two parts:

1. slurp the raw menu into a string
2. process the raw menu line-by-line to built up the array of options

Looking at the first part, I chose to initialise the menu source to the default, then use a simple `if` statement to read from standard in or a file:

```bash
# initialise the options to their default values
# â€¦
menuSource=$(dirname "$BASH_SOURCE")/menu.txt # menu.txt in script dir

# â€¦

# slurp the menu into a string
menuString=''
if [[ $menuSource == '-' ]]
then
    menuString=$(cat)
else
    menuString=$(cat "$menuSource")
fi
```

With the menu loaded into a string named `$menuString`, I then loop through it line-by-line using a here string (`<<<`). As a reminder, this operator redirects the contents of a variable to standard in:

```bash
# process the menu
declare -a menu
while read -r menuLine
do
    # skip comment lines
    echo "$menuLine" | egrep -q '^[ ]*#' && continue

    # skip empty lines
    echo "$menuLine" | egrep -q '^[ ]*$' && continue

    # store the menu item
    menu+=("$menuLine")
done <<<"$menuString"
```

The logic inside the loop is un-changed from the previous version of the script.

The only other change was updating `getopts` to remove support for the `-s` flag, and add the `-m` optional argument.

We can verify that a menu can be loaded from an alternative file by using the `-m`  optional argument to load the menu from the file `menu-montyPython.txt` which offers just one choice, `spam` ðŸ˜‰:

```bash
./pbs150-challengeSolution.sh -m menu-montyPython.txt
```

We can verify the correct handling of redirecting both standard out and standard in with the command:

```bash
echo -e "bacon\neggs\ntoast" | ./pbs150-challengeSolution.sh -m - > order.txt
```

This command redirects standard out and standard in, but the menu is still presented in the terminal, and the keyboard can still be used to enter the options. Finally, the chosen items are correctly written to `order.txt`, which you can verify with:

```bash
cat ./order.txt
```

## Followup â€” Detecting Terminals

As mentioned in the introduction, listener Jill of Kent sent me a wonderful message after we posted the previous instalment with a related tip, and I thought it was just too good not to include in the series.

One of the things you may have noticed over the years on the terminal is that some commands seem to somehow know when they're outputting to a terminal rather than a redirected stream, and behave differently in each case.

Many of the Git commands do this, for example, `git log` will show you the full Git commit history of your currently checked out branch, and when your output is going to a terminal, it will run the output through `less` for you so you get it one page at a time, waiting in your input to move to the next page. But, if you redirect the identical command to a file, the information gets written directly to the file without being run through `less` which would block the operation, e.g. `get log > log.txt`.

How does that work? Presumably, the POSIX spec provides an API for figuring out if a given stream is connected to a terminal, so the real question is, how does Bash expose this functionality?

Back in instalment XXXX we learned to use the `[[` builtin command to perform boolean tests, and we learned about some of the operators `[[` supports. As I was at pains to point out, we only looked at a sub-set of the available operators, and one of the ones we ignored, `-t` lets us test if a given file handle is a terminal or not. The syntax is a little abstract looking, because the operator works on the numeric ID for the file descriptor (`0` for standard input, `1` for standard output, and `2` for standard error). If a stream is a terminal, then `-t` will give a successful exit code, and if not, it will give an error code, so we can test if standard out is a terminal with `[[ -t 1 ]]`.

As a more practical example, let's look at `pbs151a-terminalTester.sh` from the instalment ZIP:

```bash
#!/usr/bin/env bash

# check standard input
if [[ -t 0 ]]
then
    echo 'STDIN is a terminal' >/dev/tty
else
    echo 'STDIN is NOT a terminal' >/dev/tty
fi

# check standard output
if [[ -t 1 ]]
then
    echo 'STDOUT is a terminal' >/dev/tty
else
    echo 'STDOUT is NOT a terminal' >/dev/tty
fi

# check standard error
if [[ -t 2 ]]
then
    echo 'STDERR is a terminal' >/dev/tty
else
    echo 'STDERR is NOT a terminal' >/dev/tty
fi
```

We can see this little script in action with the following commands:

```bash
./pbs151a-terminalTester.sh
echo 'pancakes' | ./pbs151a-terminalTester.sh
./pbs151a-terminalTester.sh >/dev/null
./pbs151a-terminalTester.sh 2>/dev/null
echo 'pancakes' | ./pbs151a-terminalTester.sh >/dev/null 2>&1
```

# Better String Formatting with `printf`

TO DO

## Final Thoughts

TO DO

### An Optional Challenge

TO DO