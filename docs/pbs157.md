# PBS 157 of X — Querying JSON with `jq`

So far in this mini-series we've looked at how jq can be used to [pretty-print JSON](./pbs155) and to [extract specific pieces of information](./pbs156), in this instalment we're taking things to the next level by learning how to query JSON looking for specific pieces of information.

As a prerequisite, we're going to start with a basic introduction to three important concepts, operators, functions, and filter chaining.

## Matching Podcast Episodes

TO DO

## Episode Resources

* The instalment ZIP file TO UPDATE — [pbs157.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs157.zip)

## Operators in jq

Like other programming languages, jq supports operators, i.e. symbols or keywords that apply some kind of operation to the values to their left and right to produce a new value. We'll meet more operators later in the series, but let's start with the ones we need for querying data — comparison and boolean operators.

### Comparison Operators

TO DO

### Boolean Operators

TO DO

## Functions in jq

In order query JSON we're going to need learn how to use functions in jq. At least for now, we'll be confining ourselves to using the standard functions provided by the language, but do note that it is possible to define your own jq functions too.

In jq functions are used within filters, so they have implicit access to the filter's input (i.e. `.`), which means many functions don't need any arguments at all. To call a function without arguments, simply use its name.

As you would expect, jq functions can take optional additional inputs in the form of arguments by appending them to the function name in regular round brackets separated by semi-colons (`;`). So, in jq function calls take forms like:

```jq
# no arguments
functionName

# one argument
functionName(firstArgument)

# two arguments
functionName(firstArgument; secondArgument)
```

When it comes to return values, jq functions behave like jq filters, producing zero, one, or more outputs.

Something that might surprise you, but will prove extremely useful, is that functions can take filters as arguments.

### The `length` Function

TO DO

## Filter Changing

TO DO

## MAYBE — Filter Grouping

TO DO

## The `select` Function

TO DO

## Final Thoughts

TO DO

# Examples to work towards

```jq
# the laureates for the 2000 medecine prize
jq '.prizes[]|select(.year == "2000")|select(.category == "medicine")|.laureates[]' NobelPrizes.json

# The prizes won by someone with the surname Einstein — take 1 (throws error)
jq '.prizes[]|select(any(.laureates[]; .surname == "Einstein"))' NobelPrizes.json

# the reason for the error — there are prizes with no laureats!
jq '.prizes[]|select((.laureates | length) == 0)' NobelPrizes.json

# the solution to the error — make the expansion of the laureats conditional
jq '.prizes[]|select(any(.laureates[]?; .surname == "Einstein"))' NobelPrizes.json
```



