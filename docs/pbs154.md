# PBS 154 of X ‚Äî Bash: Expansions & Brackets Redux

This final Bash instalment is mostly about putting things we already know into their proper context, but we will  learn a few new things we've skipped over too. None of these new things are vital to know, but they can be darn useful, and they'll get you instant nerd street-cred when a fellow scripter sees you using them üôÇ

## Matching Podcast Episodes

Listen along to this instalment on [episode 775 of the Chit Chat Across the Pond Podcast](https://www.podfeet.com/blog/2023/09/ccatp-775/).

<audio controls src="https://media.blubrry.com/nosillacast/traffic.libsyn.com/nosillacast/CCATP_2023_09_02.mp3?autoplay=0&loop=0&controls=1">Your browser does not support HTML 5 audio üôÅ</audio>

You can also <a href="https://media.blubrry.com/nosillacast/traffic.libsyn.com/nosillacast/CCATP_2023_09_02.mp3" >Download the MP3</a>

Read an unedited, auto-generated transcript:  <a href="https://podfeet.com/transcripts/CCATP_2023_09_02.html">CCATP_2023_09_01</a>

## Episode Resources

* The instalment ZIP file TO UPDATE ‚Äî [pbs154.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs154.zip)

## PBS 153 Challenge Solution

The challenge from the previous instalment was quite basic ‚Äî update your solution to the previous challenge to replace any duplicated code with functions.

In my previous solution there was just one obvious piece of repeated logic ‚Äî checks for whether or not something is an integer, resulting and many `if` statements starting:

```bash
if echo "$OPTARG" | egrep -q "$intRE"
```

I added a simple function definition to the top of my script:

```bash
# test if the first argument is an integer
# Arguments   : NONE
# STDIN       : value to test
# STDOUT      : NOTHING
# Return Codes:
#   0 - the value is an integer
#   1 - the value is not an integer
is_int () {
    echo "$1" | egrep -q '^[-]?\d+$' && return 0
    return 1
}
```

Which then allowed me to replace those `if` statements with simpler and clearer ones of the form:

```bash
if is_int $OPTARG
```

You'll find my full sample solution in the Instalment ZIP as `pbs153-challengeSolution.sh`.

## Command Grouping

Sometimes it's useful to run multiple commands as if they were one. Two common reasons are to have a different scope for a few commands, and to redirect streams for multiple commands at once.

When you decide you want to group commands, you have two choices:

1. Use `{ }` to run the grouped commands in the current shell, this means the commands share the same scope as the rest of the script.
2. Use `( )` to run the grouped commands in a sub-shell so they run in a copy of the script's scope, so any changes to variables don't affect the rest of the script.

As an example, this script (`pbs154a-noGrouping.sh` in the instalment) writes some output to `STDOUT`, and some to a log file:

```bash
#!/usr/bin/env bash

dessert=pancakes
echo "Dessert is $dessert"
echo "Initial dessert: $dessert">log.txt # start new file
dessert=waffles
echo "Updated dessert: $dessert">>log.txt # append
echo 'desert is tasty!'>>log.txt # append
echo "Dessert is now $dessert"
```

Notice that the first time we write the file we replace its content (`>`), then we append to it (`>>`).

Running the script and viewing the contents of the log file gives the following results:

```text
$ ./pbs154a-noGrouping.sh 
Dessert is pancakes
Dessert is now waffles
$ cat log.txt
Initial dessert: pancakes
Updated dessert: waffles
desert is tasty!
$ 
```

We can use command grouping to simpligy this script (`pbs154b-grouping.sh`):

```bash
#!/usr/bin/env bash

dessert=pancakes
echo "Dessert is $dessert"

# grouped commands
{
    echo "Initial dessert: $dessert" # no need to redirect!
    dessert=waffles
    echo "Updated dessert: $dessert" # no need to redirect!
    echo 'desert is tasty!' # no need to redirect!
}>log.txt # start new file

echo "Dessert is now $dessert"
```

Notice that in this example the `$dessert` variable inside and outside the group are in the same scope ‚Äî the change made in the group affects the code outside the group:

```text
$ ./pbs154b-grouping.sh 
Dessert is pancakes
Dessert is now waffles
$ cat log.txt
Initial dessert: pancakes
Updated dessert: waffles
desert is tasty!
$ 
```

If we change to grouping in a sub-shell then the commands inside the group see the initial value for `$dessert` from the code outside the group, but the change made is only seen inside the  group. We can see this in `pbs154c-subshell.sh`:

```bash
#!/usr/bin/env bash

dessert=pancakes
echo "Dessert is $dessert"

# grouped commands
(
    echo "Initial dessert: $dessert" # no need to redirect!
    dessert=waffles
    echo "Updated dessert: $dessert" # no need to redirect!
    echo 'desert is tasty!' # no need to redirect!
)>log.txt # start new file

echo "Dessert is still $dessert"
```

Running the script now shows the grouped commands can see the outer code's variables, but not alter them:

```text
$ ./pbs154c-subshell.sh 
Dessert is pancakes
Dessert is still pancakes
$ cat log.txt
Initial dessert: pancakes
Updated dessert: waffles
desert is tasty!
$ 
```

## Expansions in Bash

Throughout every instalment in this series-within-a-series, and throughout just about every instalment of Taming the Terminal we have been making use of shell expansions without explicitly calling attention to that fact.

When we pass arguments to terminal commands the values we type and the values received by the command are often not the same. The official name for these transformations are *Shell Expansions*.

If that sounds a but abstract, we can use the `echo` command to illustrate the point ‚Äî `echo` simply prints out the value of its arguments, so if there were no shell expansions, `echo` would print back exactly what we type in, but of course we know it does not, as illustrated by this little sequence:

```text
$ echo ~
/Users/bartbusschots
$ echo 'Hello World'
Hello World
$ echo $PWD
/Users/bartbusschots
$
```

[Bash's official documentation lists seven distinct expansions](https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html), and mentions that when all the expansions are done it performs another transformation (that for some reason is not referred to as an expansion) ‚Äî quote removal. It also lists the order in which all these transformations get applied:

1. [Brace Expansion](https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html) ‚Äî basic sequence generation, e.g. `doc{1..3}.txt` ‚Üí `doc1.txt doc2.txt doc3.txt` (new!)
2. [Tilde Expansion](https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html) ‚Äî home directory path insertion, e.g. `~/Documents` ‚Üí `/Users/bartbusschots/Documents`
3. [Shell Parameter Expansion](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html) ‚Äî insert the values of variables, e.g. `I am $USER` or `I am ${USER}`  ‚Üí  `I am bart`
4. [Command Substitution](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html) ‚Äî e.g. `today is $(date +%A)` ‚Üí `today is Wednesday`
5. [Arithmetic Expansion](https://www.gnu.org/software/bash/manual/html_node/Arithmetic-Expansion.html) ‚Äî arithmetic expressions that return values rather than success codes, e.g. `doc$(( 4 + 5 )).txt` ‚Üí `doc9.txt`
6. [Word Splitting](https://www.gnu.org/software/bash/manual/html_node/Word-Splitting.html) ‚Äî the result of any previously executed expansions gets split into separate arguments, or *words* based on the value of `$IFS`, unless they have been quoted
7. [Filename Expansion](https://www.gnu.org/software/bash/manual/html_node/Filename-Expansion.html) ‚Äî wild-card file paths, e.g. `*.txt` ‚Üí `a.txt`  & `another.txt`
8. [Quote Removal](https://www.gnu.org/software/bash/manual/html_node/Quote-Removal.html) ‚Äî any quoted arguments get their surrounding quotes removed before the value gets handed to the command

We're not going to go into detail on all of these, but I do want to draw your attention to some, and highlight some nice little power features I've not found an excuse to mention before.

TO DO ‚Äî much more detail here!

## Quick Reference/Redux ‚Äî An Ocean Brackets Summarised

One of the most confusing things to keep straight in your head when coding in Bash is the meanings of all the different kinds of brackets, so here's a quick refresher on what we've learned. Hopefully this concise list will prove a useful quick-reference going forward.

| Brackets | Description                                                  | Special Rules                                                | Result    |
| :------: | ------------------------------------------------------------ | ------------------------------------------------------------ | --------- |
|  `[ ]`   | **Legacy tests** ‚Äî included in Bash for backwards compatibility with SH, **do not use** |                                                              |           |
| `[[ ]]`  | **Tests** ‚Äî evaluate a boolean expression to an exit code. Primarily used in `if` statements, e.g. `if [[ $n -eq 4 ]]; then echo 'FOUR!'; fi` | Variables do not need to be quoted                           | Exit code |
|  `${ }`  | **Variable expansion** ‚Äî fetch the value of a variable. The braces can be omitted when the variable is not an array and the variable name has no special characters. E.g. `echo "I am ${User}"` or `echo "I am $User"` |                                                              | String    |
|  `$()`   | **Sub-shell Expansion** ‚Äî execute commands in a sub-shell and substitute with text from `STDOUT`. E.g. `echo "It's now $(date)"` |                                                              | String    |
| `$(( ))` | **Arithmetic Expansion** ‚Äî perform calculation and substitute the result, e.g. `echo "1 + 1 = $(( 1 + 1 ))"` | Automatic variable expansion ‚Äî use `x` instead of `${x}` or `$x` | String    |
|  `( )`   | **Sub-shell Command Grouping** ‚Äî execute the contained commands in a sub-shell, evaluates to the exit code of the last executed command within. Variables are inherited, but changes have no effect outside. |                                                              | Exit code |
|  `{ }`   | **Command Grouping** ‚Äî combine multiple commands into one without creating a sub-shell. |                                                              | Exit code |

## Final Thoughts

TO DO
