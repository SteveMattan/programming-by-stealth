---
title: Working with Submodules
instalment: 174
miniseries: Git
creators: [bart, allison]
date: 2024-12-07
---
TO DO

## Matching Podcast Episode

TO DO

## A (Reminder) Note on Default Git Security Settings

TO CONDENSE MASSIVELY

For security reasons, modern versions of Git prevent the use of file paths as Git URLs under some circumstances. Git commands where a human direcrly enters the file path URL are permitted, but when one Git command triggers others, the triggered commands can't use file path URLs.

When you run afowl of this security default you'll get an error like:

```text
fatal: transport 'file' not allowed
```

**In the real world** you're most likely to do working with genuinely remote repositories over SSH or HTTPS, so you're **not likely to encounter this problem**.

However, in order keep our worked examples in this isntalment self-contained, we need to use local folders to simulate remote repositorie, so, we will encounter this problem.

The Git setting that controls whether or not file URLs are permitted is `protocol.file.allow`, and it has three possible values:

1. `never` — regardless of context, don't allow file URLs
2. `user` — file URLs are allowed by direct user actions, but not indirectly, i.e. not within a triggered Git command. This is the default.
3. `always` — file URLS can be used in any context, i.e. for direct user actions, and, within any triggered Got commands.

### A Per-Command Exemption (Used in our Examples)

Git's security defaults were added for good reasons, so we want to make the minimal possible exception to faciliate our examples. Rather than setting the configuration globally, we'll set `protocol.file.allow` to `always` (direct and triggered commands) on a per-command basis, and only when we need to. This means that the moment our command and its triggered commands finish, the exception will disappear.

The mechanism for doing this is Git's  `-c` option for passing a value for any configuration variable at run time, the option takles the form `-c NAME_OF_SETTING=VALUE`, so to enable file URLs in all contexts we need to add the following to any Git commands that trigger other Git commands:

```
-c protocol.file.allow=always
```

### A Permanent Excemption (Only use if you Regularly use File Path URLs)

It's possible that you want to use submodules in an environment where file-based URLs are the norm. The only realistic example I cna think if would be an organisation that hosts its Git repositores on a shared folder that gets mapped as a drive on developer PCs. In such a scenario, you probably want to make a permanent exception, which you can do by updating Git's configiration for the current user with the command `git config --global` command:

```sh
# WARNING - THIS ADDS A PERMANENT SECURITY EXCEPTION
git config --global protocol.file.allow always
```

But remember, this is not recommended!

## Reminder — Our Overall Scenario,  a Small Web App Business

TO CONDENSE

To explore Git submodules we're going to pretend to be a fledgeling business that builds web apps, all of which share the company's branding.

To keep things consistent across current and future apps, the branding is versioned in its own private Git repository named `pbscorp-brand`. Each web app has its own repo, with names like `pbscorp-app1`.  The app repos link the brand repo in as a git submodule.

TO UPDATE FROM HERE TO END OF SECTION 

To play along, start by downloading the instalment ZIP file, extracting it, and opening a terminal in the extracted folder, and executing the initialisation script `initPBS173Demo.sh` with the commands:

```sh
chmod +x *.sh; ./initPBS173Demo.sh
```

This script does the following:

1. Creates parent folders to simulate Git repositories on different computers: 
   1. `remote-repos` to represent the company's GIT server
   2. `pc-app1Dev` to represent the PC of a newly hired developer who's just been assigned to app 1
   3. `pc-app2Dev` to represent the PC of a developer tasked with creating the brand-new app 2
   4. `pc-brandDesigner` to represent the PC of a designer tasked with maintaining the brand
2. Expands the bundled repos `pbscorp-brand.bundle` and `pbscorp-app1.bundle` into the repositories `pbscorp-brand` & `pbscorp-app1` in the `remote-repos` folder

## Scenario 4 — Pushing Submodule changes (Extending the Brand from App 2)

Up to this point we have used submodules to import content and changes into our repo, but submodules allow a fully two-way interaction like any other Git repo does.

To prove this point, let's play the role of the developer of App 2, and edit the brand which we've consumed as a submodule, and then push that change up to the remote brand repository.

TO DO

## Scenario 5 — Branching with Submodules (Testing a Brand Change)

So far, we've worked on a single branch in all repositories, but in this final scenario, it's time to change that. We're going to perform as controlled rollout of a new brand using staging branches in the brand repository as well as the repositories for App 1 & App 2 which consume the brand repository as a submodule.

TO DO

## Final Thoughts

TO DO
