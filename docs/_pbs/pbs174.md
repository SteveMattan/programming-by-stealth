---
title: Working with Submodules
instalment: 174
miniseries: Git
creators: [bart, allison]
date: 2024-12-07
---
This is the third of three instalments exploring git's support for nested repositories through so-called *Git submodules*. In [the first instalment](./pbs172) we focued purely on the theory and the motivations, then, in the second we got practical, learning how to use the `git module`  command to nest one repository within another. We used a simplified but realistic scenario of a small software company to explore some common actions developers are likely to need to do with Git submodules. Those actions were all realistic, but they were all very basic, and involved passively consuming content from the remote repository. We'll start this instalment with a scenario where we push code changes from our submodule back to the remote repository. Then, we'll use a second scenario to explore how Git submodules handle branching.

## Matching Podcast Episode

TO DO

## A (Reminder) Note on Default Git Security Settings

In the previous instalment we explained that for security reasons, Git prevents the use of file path URLs in Git commands triggered by other Git commands by default. Because our examples simulate multiple computers with multiple folders, we need to use file path URLs, so, some of our example commands need to use the `-c` option to make a single-command exception to this security default. Specifically, any Git command we use that triggers other Git commands needs to include the following option:

```sh
-c protocol.file.allow=always
```

If we forget to do this we'll get errors like:

```text
fatal: transport 'file' not allowed
```

Again, just a reminder that in the real world you're most likely to be working with genuinely remote repositories over SSH or HTTPS, so you're unlikely to encounter this issue.

## Reminder — Our Overall Scenario,  a Small Web App Business

We're going to continue to illustrate the use of Git submodules from with examples from our imaginary fledgeling web app business that builds web apps PBS Corp. When we left off we had an imagined Git server with three repositories:

1. `pbscorp-brand` — the company's unified style
2. `pbscorp-app1` — the company's first web app, it links the folder `brand` to `pbscorps-brand` using a Git submodule.
3. `pbscorp-app2` — the company's second web app which also links a folder `brand` to `pbscorps-brand` using a Git submodule.

To play along, start by downloading the instalment ZIP file, extracting it, and opening a terminal in the extracted folder, and executing the initialisation script `initPBS174Demo.sh` with the commands:

```sh
chmod +x *.sh; ./initPBS174Demo.sh
```

This script does the following:

1. Creates parent folders to simulate Git repositories on different computers: 
   1. `remote-repos` to represent the company's GIT server
   2. `pc-app1Dev` to represent the PC of a developer working on app 1
   3. `pc-app2Dev` to represent the PC of a developer working on app 2
   4. `pc-brandDesigner` to represent the PC of a designer tasked with maintaining the brand
2. Expands the bundled repos `pbscorp-brand.bundle` , `pbscorp-app1.bundle` & `pbscorp-app2.bundle` into the headless repositories `pbscorp-brand.git` , `pbscorp-app1.git` & `pbscorp-app2.git` in the `remote-repos` folder
3. Clones the appropriate repos to each PC folder and initialises the submodules as appropriate

## Scenario 4 — Pushing Submodule changes (Extending the Brand from App 2)

Up to this point we've only used submodules to bring content and changes into our repos, but submodules since submodules are just Git repos, they allow the usual push and pull two-way interaction.

To prove this point, let's play the role of the developer of App 2. Our app has branding needs beyond those in App 1, so we want to extend the brand, and push that change up to the officail repo for the brand on the company's Git server. 

To play along, start by changing into the App 2 repo in the folder represening the App 2 developer's PC (`pc-app2Dev/pbscorp-app2`).

In here you should find a chedked out up-to-date copy of the repo with its submodule initialised just as we left it at the end of the previous instalment. We can verify this by running the following commands and opening the `index.html` file in our favourite browser.

First, let's make sure the outer repo us up-to-date with a fetch (including the submodules to save time) and then a status:

```sh
git fetch --recurse-submodules
git status
```

You should see that we're up to date with a clean working copy:

```text
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

We can also check that the brand submodule is up-to-date and ready for us to make a change. Let's start by changing into it:

```sh
cd brand
```

If we now run a `git status` we see someting we may not expect:

```text
HEAD detached at d223950
nothing to commit, working tree clean
```

We have a detached head! This is not a problem when you're only going to pull changes to all submodules from the outer repo, using `git submodule update` will work fine, but it is a problem if we want to use our submodule as a regular repo and push changes as well as pushg them. It's very easy to fix though, simply check out `main`:

```sh
git checkout main
```

Now when we run another `git status` we can see we're in just the state we want to be:

```text
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

We're now ready to make our change.

LEFT OFF HERE!!!

## Scenario 5 — Branching with Submodules (Testing a Brand Change)

So far, we've worked on a single branch in all repositories, but in this final scenario, it's time to change that. We're going to perform as controlled rollout of a new brand using staging branches in the brand repository as well as the repositories for App 1 & App 2 which consume the brand repository as a submodule.

TO DO

## Final Thoughts

TO DO
