---
title: Working with Submodules
instalment: 174
miniseries: Git
creators: [bart, allison]
date: 2024-12-07
---
This is the third of three instalments exploring git's support for nested repositories through so-called *Git submodules*. In [the first instalment](./pbs172) we focued purely on the theory and the motivations, then, in the second we got practical, learning how to use the `git module`  command to nest one repository within another. We used a simplified but realistic scenario of a small software company to explore some common actions developers are likely to need to do with Git submodules. Those actions were all realistic, but they were all very basic, and involved passively consuming content from the remote repository. We'll start this instalment with a scenario where we push code changes from our submodule back to the remote repository. Then, we'll use a second scenario to explore how Git submodules handle branching.

## Matching Podcast Episode

TO DO

## A (Reminder) Note on Default Git Security Settings

In the previous instalment we explained that for security reasons, Git prevents the use of file path URLs in Git commands triggered by other Git commands by default. Because our examples simulate multiple computers with multiple folders, we need to use file path URLs, so, some of our example commands need to use the `-c` option to make a single-command exception to this security default. Specifically, any Git command we use that triggers other Git commands needs to include the following option:

```sh
-c protocol.file.allow=always
```

If we forget to do this we'll get errors like:

```text
fatal: transport 'file' not allowed
```

Again, just a reminder that in the real world you're most likely to be working with genuinely remote repositories over SSH or HTTPS, so you're unlikely to encounter this issue.

## Reminder — Our Overall Scenario,  a Small Web App Business

We're going to continue to illustrate the use of Git submodules from with examples from our imaginary fledgeling web app business that builds web apps PBS Corp. When we left off we had an imagined Git server with three repositories:

1. `pbscorp-brand` — the company's unified style
2. `pbscorp-app1` — the company's first web app, it links the folder `brand` to `pbscorps-brand` using a Git submodule.
3. `pbscorp-app2` — the company's second web app which also links a folder `brand` to `pbscorps-brand` using a Git submodule.

To play along, start by downloading the instalment ZIP file, extracting it, and opening a terminal in the extracted folder, and executing the initialisation script `initPBS174Demo.sh` with the commands:

```sh
chmod +x *.sh; ./initPBS174Demo.sh
```

This script does the following:

1. Creates parent folders to simulate Git repositories on different computers: 
   1. `remote-repos` to represent the company's GIT server
   2. `pc-app1Dev` to represent the PC of a developer working on app 1
   3. `pc-app2Dev` to represent the PC of a developer working on app 2
   4. `pc-brandDesigner` to represent the PC of a designer tasked with maintaining the brand
2. Expands the bundled repos `pbscorp-brand.bundle` , `pbscorp-app1.bundle` & `pbscorp-app2.bundle` into the headless repositories `pbscorp-brand.git` , `pbscorp-app1.git` & `pbscorp-app2.git` in the `remote-repos` folder
3. Clones the appropriate repos to each PC folder and initialises the submodules as appropriate

## Scenario 4 — Pushing Submodule changes (Extending the Brand from App 2)

Up to this point we've only used submodules to bring content and changes into our repos, but submodules since submodules are just Git repos, they allow the usual push and pull two-way interaction.

To prove this point, let's play the role of the developer of App 2.

If you'd like to play along, start by changing into the App 2 repo in the folder represening the App 2 developer's PC (`pc-app2Dev/pbscorp-app2`).

In here you'll find a fully checked out and initialised copy of App 2 just as we left it at the end of the previous instalment. We can prove this to ourselves by opening  `index.html`  in our favourite browser.

We've received some feedback from users that the display of the seconds to Christmas just do not stand out enough.

Our first instinct is to just make the countdown bigger, so we edit `index.html` to add the Boostrap 5 CSS class `display-3` to the paragraph that contains the number, the updated paragraph looks like this:

```html
<p class="numeric display-3" id="output">?</p>
```

You can edit the file in the repo yourself, or, replace it with an updated version of the full file named `pbscorp-app2-index-1.html` from the root of the instalment ZIP with the command:

```sh
cp ../../pbscorp-app2-index-1.html index.html
```

If we refresh our browser we'll see that things look a little better, but they're not quite good enough yet. We really need a better font, one more suited for numeric data!

Note that the paragraph already has the CSS class `numeric`,  we could add some custom CSS within just App 2 to stlye that class with a nice font. But the need to display numeric data is likely to be useful in other future apps, so really, we should expand the corporate brand to provide good styling for numeric data.

The first step is to change into the brand submodule folder and make sure we're up-to-date and ready to make our edits, commit, and push them.

Start by changing into the `brand` folder:

```sh
cd brand
```

Next, let's make sure we're up-to-date by doing a `fetch` and then showing our stats:

```sh
git fetch && git status
```

You'll notice that the output is not quite what we would like:

```text
HEAD detached at d223950
nothing to commit, working tree clean
```

Our working tree is clean, but we have a detached head! This is not a problem when you're only planning to pull changes to all submodule using the outside-in approach we saw in scenario 3b in the previous instalment. But, it most certainly is a problem when we plan to make changes and push them!

Don't worry, this is an easy problem to resolve — simply check out `main`:

```sh
git checkout main
```

Now when we run another `git status` we can see we're in exactly the state we want to be:

```text
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

We're now ready to try update the style to meet our needs. After a lot of time-wating on [Google Fonts](https://fonts.google.com/) we decide to use the [Rationale](https://fonts.google.com/specimen/Rationale?preview.text=1234567890) font in red. To do this we need to make two updates to `style.css`:

1. We need to update the line that imports the brand's web fonts to add Rationale to the list, the new line is:
   ```css
   @import url('https://fonts.googleapis.com/css2?family=Chewy&family=Comfortaa:wght@300..700&family=Rationale&display=swap');
   ```

2. We need to add some style attributes for the CSS class `.numeric` so it applies the font correctly and sets the colour to an appropriate shade of red:
   ```css
   /* Customise the display of numeric data */
   .numeric{
       font-family: "Rationale", sans-serif;
       font-weight: 400;
       font-style: normal;
       color: #990000;
   }
   ```

You can make the changes to `style.css` yourself, or replace it with an updated version of the full file named `pbscorp-brand-style-1.css` from the root of the instalment ZIP with the command:

```sh
cp ../../../pbscorp-brand-style-1.css style.css
```

 If you refresh the app in your browser you'll see it now looks a lot better!

We're working in the brand submodule repo, so let's see how things stand here with a quick `git status`:

```text
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   style.css

no changes added to commit (use "git add" and/or "git commit -a")
```

Just as we expected, one modified file waiting to be committed and pushed:

```sh
git commit -am 'Feat: add support for displaying numeric data'
git push
```

Let's move back to the outer repo to see how things stand there:

```sh
cd ..
```

Again, run `git status`:

```text
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   brand (new commits)
        modified:   index.html

no changes added to commit (use "git add" and/or "git commit -a")
```

As expected, we have two changes waiting to be committed — our update to `index.html` to add the `display-3` class, and the new current commit in the `brand` submodule.

We can now finish our day's work with an other commit and push:

```sh
git commit -am 'Feat: improve the display of the countdown number to address customer feedback'
git push
```

## Scenario 5 — Branching with Submodules (Testing a Brand Change)

So far, we've worked on a single branch in all repositories, but in this final scenario, it's time to change that. We're going to perform as controlled rollout of a new brand using staging branches in the brand repository as well as the repositories for App 1 & App 2 which consume the brand repository as a submodule.

TO DO

## Final Thoughts

TO DO
