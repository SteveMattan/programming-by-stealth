---
title: Working with Submodules
instalment: 174
miniseries: Git
creators: [bart, allison]
date: 2024-12-07
---
This is the third of three instalments exploring git's support for nested repositories through so-called *Git submodules*. In [the first instalment](./pbs172) we focued purely on the theory and the motivations, then, in the second we got practical, learning how to use the `git module`  command to nest one repository within another. We used a simplified but realistic scenario of a small software company to explore some common actions developers are likely to need to do with Git submodules. Those actions were all realistic, but they were all very basic, and involved passively consuming content from the remote repository. We'll start this instalment with a scenario where we push code changes from our submodule back to the remote repository. Then, we'll use a second scenario to explore how Git submodules handle branching.

## Matching Podcast Episode

TO DO

## A (Reminder) Note on Default Git Security Settings

In the previous instalment we explained that for security reasons, Git prevents the use of file path URLs in Git commands triggered by other Git commands by default. Because our examples simulate multiple computers with multiple folders, we need to use file path URLs, so, some of our example commands need to use the `-c` option to make a single-command exception to this security default. Specifically, any Git command we use that triggers other Git commands needs to include the following option:

```sh
-c protocol.file.allow=always
```

If we forget to do this we'll get errors like:

```text
fatal: transport 'file' not allowed
```

Again, just a reminder that in the real world you're most likely to be working with genuinely remote repositories over SSH or HTTPS, so you're unlikely to encounter this issue.

## Reminder — Our Overall Scenario,  a Small Web App Business

We're going to continue to illustrate the use of Git submodules from with examples from our imaginary fledgeling web app business that builds web apps PBS Corp. When we left off we had an imagined Git server with three repositories:

1. `pbscorp-brand` — the company's unified style
2. `pbscorp-app1` — the company's first web app, it links the folder `brand` to `pbscorps-brand` using a Git submodule.
3. `pbscorp-app2` — the company's second web app which also links a folder `brand` to `pbscorps-brand` using a Git submodule.

To play along, start by downloading the instalment ZIP file, extracting it, and opening a terminal in the extracted folder, and executing the initialisation script `initPBS174Demo.sh` with the commands:

```sh
chmod +x *.sh; ./initPBS174Demo.sh
```

This script does the following:

1. Creates parent folders to simulate Git repositories on different computers: 
   1. `remote-repos` to represent the company's GIT server
   2. `pc-app1Dev` to represent the PC of a developer working on app 1
   3. `pc-app2Dev` to represent the PC of a developer working on app 2
   4. `pc-brandDesigner` to represent the PC of a designer tasked with maintaining the brand
2. Expands the bundled repos `pbscorp-brand.bundle` , `pbscorp-app1.bundle` & `pbscorp-app2.bundle` into the headless repositories `pbscorp-brand.git` , `pbscorp-app1.git` & `pbscorp-app2.git` in the `remote-repos` folder
3. Clones the appropriate repos to each PC folder and initialises the submodules as appropriate

## Scenario 4 — Pushing Submodule changes (Extending the Brand from App 2)

Up to this point we've only used submodules to bring content and changes into our repos, but submodules since submodules are just Git repos, they allow the usual push and pull two-way interaction.

To prove this point, let's play the role of the developer of App 2.

If you'd like to play along, start by changing into the App 2 repo in the folder represening the App 2 developer's PC (`pc-app2Dev/pbscorp-app2`).

In here you'll find a fully checked out and initialised copy of App 2 just as we left it at the end of the previous instalment. We can prove this to ourselves by opening  `index.html`  in our favourite browser.

We've received some feedback from users that the display of the seconds to Christmas just do not stand out enough.

Our first instinct is to just make the countdown bigger, so we edit `index.html` to add the Boostrap 5 CSS class `display-3` to the paragraph that contains the number, the updated paragraph looks like this:

```html
<p class="numeric display-3" id="output">?</p>
```

You can edit the file in the repo yourself, or, replace it with an updated version of the full file named `pbscorp-app2-index-1.html` from the root of the instalment ZIP with the command:

```sh
cp ../../pbscorp-app2-index-1.html index.html
```

If we refresh our browser we'll see that things look a little better, but they're not quite good enough yet. We really need a better font, one more suited for numeric data!

Note that the paragraph already has the CSS class `numeric`,  we could add some custom CSS within just App 2 to stlye that class with a nice font. But the need to display numeric data is likely to be useful in other future apps, so really, we should expand the corporate brand to provide good styling for numeric data.

The first step is to change into the brand submodule folder and make sure we're up-to-date and ready to make our edits, commit, and push them.

Start by changing into the `brand` folder:

```sh
cd brand
```

Next, let's make sure we're up-to-date by doing a `fetch` and then showing our stats:

```sh
git fetch && git status
```

You'll notice that the output is not quite what we would like:

```text
HEAD detached at d223950
nothing to commit, working tree clean
```

Our working tree is clean, but we have a detached head! This is not a problem when you're only planning to pull changes to all submodule using the outside-in approach we saw in scenario 3b in the previous instalment. But, it most certainly is a problem when we plan to make changes and push them!

Don't worry, this is an easy problem to resolve — simply check out `main`:

```sh
git checkout main
```

Now when we run another `git status` we can see we're in exactly the state we want to be:

```text
On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean
```

We're now ready to try update the style to meet our needs. After a lot of time-wating on [Google Fonts](https://fonts.google.com/) we decide to use the [Rationale](https://fonts.google.com/specimen/Rationale?preview.text=1234567890) font in red. To do this we need to make two updates to `style.css`:

1. We need to update the line that imports the brand's web fonts to add Rationale to the list, the new line is:
   ```css
   @import url('https://fonts.googleapis.com/css2?family=Chewy&family=Comfortaa:wght@300..700&family=Rationale&display=swap');
   ```

2. We need to add some style attributes for the CSS class `.numeric` so it applies the font correctly and sets the colour to an appropriate shade of red:
   ```css
   /* Customise the display of numeric data */
   .numeric{
       font-family: "Rationale", sans-serif;
       font-weight: 400;
       font-style: normal;
       color: #990000;
   }
   ```

You can make the changes to `style.css` yourself, or replace it with an updated version of the full file named `pbscorp-brand-style-1.css` from the root of the instalment ZIP with the command:

```sh
cp ../../../pbscorp-brand-style-1.css style.css
```

 If you refresh the app in your browser you'll see it now looks a lot better!

We're working in the brand submodule repo, so let's see how things stand here with a quick `git status`:

```text
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   style.css

no changes added to commit (use "git add" and/or "git commit -a")
```

Just as we expected, one modified file waiting to be committed and pushed:

```sh
git commit -am 'Feat: add support for displaying numeric data'
git push
```

Let's move back to the outer repo to see how things stand there:

```sh
cd ..
```

Again, run `git status`:

```text
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   brand (new commits)
        modified:   index.html

no changes added to commit (use "git add" and/or "git commit -a")
```

As expected, we have two changes waiting to be committed — our update to `index.html` to add the `display-3` class, and the new current commit in the `brand` submodule.

We can now finish our day's work with an other commit and push:

```sh
git commit -am 'Feat: improve the display of the countdown number to address customer feedback'
git push
```

## Scenario 5 — Branching with Submodules (Testing a Brand Change)

So far, we've worked on a single branch in all repositories, but in this final scenario, it's time to change that. We're going to perform as controlled rollout of a new brand using staging branches in the brand repository as well as the repositories for App 1 & App 2 which consume the brand repository as a submodule.

In this scenario we're going to make a controlled transition to a whole new brand — a version 2.0!

### Laying Some Ground Work

PBS Corp is a young company, and like many young companies, they didn't think everything through all the way on day 1. This major re-brand is their first, and it's become clear to the lead developer that the Git repositories need some more structure.

While we haven't see it in our scenarios, PBS Corps have had the following simple branching policy for their repositories:

1. Only production-ready tested code should be committed to the `main` branch
2. Any experimentation should be done on branches with names pre-fixed with `wip-`

This complete re-think of the brand is the first time PBS Corps has had any of their repos move from a 1.* to a 2.* major version, and it's highlighted the short-coming of having only a single branch designated as production-ready (`main`). The transition from the original brand to the new brand will be rolled out slowly, one app at a time, so it may be necessary to apply bug fixes to the production-ready version of the 1.* brand while some apps are already using the production-ready version of the 2.* brand. Clearly, multiple production-ready branches will be needed in future, at least one for each major version. The decision is made to designate branches named `stable-vX`, where `X` is a major version number, as production-ready, just like `main` has been to date. The question then becomes, what to do with `main`? Technically it could be deleted, but by convention, `main` is the default branch, so removing it would cause confusion. Instead, the decision is made to keep `main` at the same commit as the default `stable` branch that developers should use for new projects. Effectively, `main` will point to the primary production-ready branch.

Additionally, a budget has been released to build dedicated staging servers for testing updates.

Putting it all together, the chief software engineer announces an updated branching policy:

1. Only production-ready tested code should be committed to the `main` branch, or any branch named with the `stable` pre-fix
2. Repositories for projects that have **not** yet reached major version 2 will have just one production-ready branch, `main`
3. Repositories for projects that **have** reached  major version 2 will:
   1. Have separate production-ready branches for each major version named `stable-vX`, where `X` is the major version number
   2. Retain their `main` branch, but keep it in lock-step with the default stable branch that should be used be developers starting new projects
4. Repositories for projects that have been configured on the staging infrastructure will have a branch named `staging` which will be connected to the staging server via a CI/CD pipeline
5. Any experimentation should be done on branches with names pre-fixed with `wip-`

Now, management feel PBS Corps is ready to implement its re-branding, and their project plan breaks the work down into the following phases:

1. The sysadmins prepare the repositories for the change:
   1. Add the needed new branches to the brand repo
   2. Add staging branches to the repos for App 1 & App 2
2. The brand designer pushes the new brand to the `stable-v2` branch in the `pbscorps-brand` repo
3. The developer for App 1 tests the updated brand in staging
4. The developer for App 1 pushes the updated brand to production

### Scenario 5a — Sysadmin Prepares Repos

Nothing the sysadmin needs to do has not been covered many times before in this Git series, so rahter than manually stepping through the process, I have captured all the work in a script. Like with the init script used at the start of this and the previous instalments, the script will echo the commands it is about to run and their output, so you can see exactly what the sysadmin had to do.

To run the script, change to the base folder of the Installment ZIP and run the following command:

```sh
./initPBS174Demo-scenario5.sh
```



## Final Thoughts

TO DO
