---
title: MVC in XKpasswd-js
instalment: 171
creators: [bart, allison, helma]
---
As explained in the [previous instalment](https://pbs.bartificer.net/pbs170) the new XKPasswd-js code uses the MVC pattern to structure the code.
This instalment will explain this in more detail and also some of the choices why this was done.

In the very first web version of XKPasswd-js, the UI was 99% static HTML. Life was easy because the only action needed was the push of the Generate button. It took only a little bit of code to add the generated passwords to the text area that was already created in the HTML, with an `id` set for easier reference.
Thanks to the use of Bootstrap version 5, there were already a dropdown menu, a responsive hamburger menu and an accordion to hold the configuration information. All these elements contained placeholders but all were already fully functional.
The focus was on getting the actual password generation code to work.

Slowly, over time the placeholders were replaced by working code and the main file, `index.mjs`, grew bigger and became more complex. It was time to break the code up into multiple classes. 
There are many reasons to break up a complex file.

When a file has hundreds of lines and you need to refer to a different part of the file, you are either scrolling up and down through the file, inevitably losing your editing spot or you need an editor that can display different locations of a single file side by side.  
Oftentimes, in such a file, you tend to create long functions that perform long and complex tasks. Before you know it, you even need to scroll within a function to reference some code.

Put this code aside for a few weeks and by the time you get back to it, you'll be scratching your head on where to begin adding new features or fixing bugs.

Tired of scrolling and losing hair from scratching will lead to breaking up long functions in to shorter ones, but then you also need a kind of table of contents of all the functions you've created, because there will be many. 
Sure, any good IDE will provide this functionality but scrolling is now replaced by jumping around using the table of contents.

Another reason for breaking up a long and complex file is unit testing. A unit test is, as the name implies, a test that checks the functionality of a single unit. A unit in code is a function or method. It is very difficult to write unit tests for complex functions that call other functions you also need to test. This means, it becomes very difficult to test the various functions in isolation.

And it becomes almost impossible to unit test a function if it also manipulates the UI, e.g. one function handles the button press, generates the passwords AND updates the text area with the passwords.

Time for the implementation of the MVC pattern.

Usually the MVC leads to a trio of classes, the Model class, the Controller class and the View class. Together they take care of some aspect of the application or of the entire functionality of the application, depending on the size and complexity of the application.
In XKPasswd-js there is just one Model, but multiple Controller and View pairs.

## Model

The heart of the application, aka the business logic aka the reason for its existence, is the port from the old Perl library to Javascript. As we learned last time, this is the model in the MVC pattern.

The code for the model can be found in the `lib` directory of the source code and it uses one class as a gateway to all the other classes. This gateway class is the `XKPasswd` class. None of the other classes are accessed directly, everything goes through the `XKPasswd` class. In fact, this gateway setup is also a design pattern.

This gateway setup allows us to take contents of the `lib` directory any time in the future and create a CLI application out of it by simply adding one or more classes that become the command line 'view' the user interacts with.

This gateway setup also allows us to keep the model and the various views (both web and CLI) in one git repository and still build various versions of the application.

Finally, because these classes only deal with the business logic, it is very easy to test them with Jest tests. Writing tests for UI manipulation is the hardest part of testing. By separating the Model from the View and the Controller it becomes much easier to write tests for the model.

Due to this setup, there is just one Model which is used by all the Controllers.

## Views and Controllers

Rule of thumb for the UI of XKPasswd is _if it can be done in static HTML, it will be added to index.html_. This reduces the Javascript part of the view to change visibility and CSS classes of existing objects and to fill or empty the input fields.
These functions are usually so trivial they don't need any unit tests. So less unit tests to write.

XKPasswd has two main areas in the UI, the part where the configuration can be changed and the part where the passwords are generated and displayed along with the statistics. The configuration part can be separated in the preset part and the individual settings part.
The way the classes in the `lib` directory are set up, also match this separation.

The preset part is very straightforward. It displays the available presets along with the description of that preset. The selected preset is displayed in the header of the box.

The password part is also quite simple. It handles the input of the number of passwords and displays the generated passwords and the statistics. Finally it handles the copy actions of the passwords and the switch between list and textarea.

The most complicated part is the settings part with a lot of input fields which need to be shown or hidden based on the value of other fields and show or hide error messages when the input is not correct.

To keep the code manageable it was also divided in three parts with a View and a Controller pair for each part.

All these classes are initialized in `index.mjs` in the `XKP` object. This object serves a wrapper around all the code in the `index.mjs` file to prevent it from being in the global namespace.

## Views

The constructor of the Views classes initialise class variables with jQuery objects of the HTML elements that are relevant to the part they focus on. So e.g. the PresetView class has variables for the header of the preset box, the element that holds the buttons and the element that holds the description.

These Views classes also have one or more functions with a name that starts with 'bind'. This function binds an event handler to the relevant HTML elements. It takes one parameter called `handle`. This is a reference to a function of the Controller to handle the action that this event initiated.
I call these functions bind functions, because the word 'bind' is in the name and it binds an event handler in the View class to a function in the Controller class.

Finally these Views classes contain helper functions to make showing/hiding or other actions easier to call.

## Controllers

In the constructor of the Controller classes several class variables are initialized with references to the model class (always the `XKPasswd` class) and the respective View class. If necessary, the Controller also has variables for the other Controllers it needs to address.

The constructor also calls the bind function of the View class and passes its own function that needs to handle the data that is created by the user through the View. 

If necessary the Controller class has one or more helper functions that call a helper function in its View class. These Controller helper functions can be called by other Controllers in case the UI needs to change and that change is not the responsibility of the controller that wants to change the UI.

# Example

To get a better idea of how such a bind function works, let's look at the bind function of the PasswordView class, because that's the easiest one.

```javascript
bindGeneratePassword(handle) {  
      
      $('form#generatePasswords').on('submit', (e) => {  
        e.preventDefault();  
        e.stopPropagation(); // stop the event bubbling  
      
        let num = parseInt(this.#numberOfPasswords.val());  
        if (isNaN(num) || num < 1) {  
          num = 1;  
          this.#numberOfPasswords.val(num);  
        }  
        handle(num);  
      });  
    };
```

It creates a submit handler for the form with the number of passwords. This submit handler reads the number of passwords, checks if it's a positive number, if not, sets the number to 1, and passes the number to the `handle` function.

The PasswordController calls this `bindGeneratePassword` function and passes its own `generatePasswords` function as parameter.

```javascript
this.#view.bindGeneratePassword(this.generatePasswords);
```

In turn, the `generatePasswords` function calls the `XKPasswd` class, the Gateway class, to generate the number of passwords given and passes that on to the PasswordView class to render the passwords. Rendering just means displaying the information in the predefined way.

This looks like a difficult way to perform an action, but by splitting the action over different classes, it becomes easier to change one of them, without affecting the others. E.g. we could totally change the way the number is entered and how the passwords are displayed, but there is no change in the way the PasswordController passes the number onto the `XKPasswd` class nor is there any change in the code that generates the passwords.
On the other hand, when we would change the way the Controllers are set up, there would be no change in code in the View class, nor in the `XKPasswd` class.

## A fourth Controller and View pair

In June (2024) Luis Tavares, also known as _irsheep_, created a pull request to add a much requested feature: a way to store and retrieve the current settings. 
His implementation was to create an encoded blob that contain the settings and add that as a query parameter to the url of the XKPasswd website. You can copy that url and bookmark it and Luis' code will decode the blob and fill the settings according to your preferences.

I was implementing a similar feature to import and export configuration as JSON files, and I was debating where to put the code for the View and the Controller actions. 

Luis' code was basically doing the same thing but starting from a different position and he created a Config class. So, why not combine the different ways to save and reuse a specific setting. 
The code is rearranged to create a ConfigView and a ConfigController class.

It doesn't matter that the import and export of the JSON files is in the menu and the settings link is under the Settings box. That is for the ConfigView to handle. 

The ConfigController handles the reading and writing of the JSON files and the encoding and decoding of the settings link. It also tells the PresetController there is an extra 'CUSTOM' preset and the SettingsController to display the custom settings. Finally, it takes care of updating the settingslink. So whenever the settings change, the SettingsController calls the ConfigController to update the settings link.
