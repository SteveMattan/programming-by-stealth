---
title: Submodules
instalment: 172
miniseries: Git
creators: [bart, allison]
date: 2024-10-26
---
We're making a quick detour back to Git to have a look at one of the more advanced topics I intentionally skipped on our first look at Git because it didn't solve a relevant problem. As we move forward with the XKPasswd project that's changing, and it's also changing in other adjacent contexts too, so, it's time to meet the concept of *Git Submodules*. In other words, it's time to look at nesting Git repositories.

## Matching Podcast Episode

TO DO

## Instalment Resources

*None*

## Why Nest Repositories?

Given how versatile a tools Git it, and how many ways people use it to solve so many different problems, it shouldn't come as a surprise that there are more uses for Git submodules than anyone could possible list. So, we're going to look at just three example uses that are important to me, and seem relevant to this audience:

1. Deploying Plugin-based Web Apps
2. Sub-dividing a Document Repository 
3. Including Dependencies in Apps

I've listed these in reverse order of relevance to the PBS series, so we'll finish with the use-case we'll use in our examples.

### Use-Case 1 — Deploying Plugin-based Web Apps at Scale

In this series we mostly view things from the developer's point of view, it is called *__programming__ by stealth* after all, but from time to time we've also looked at the world from the sysadmin's point of view, especially in the ChezMoi and Bash scripting mini-series. This example looks at deploying software from a sysadmin's point of view, and it was my first exposure to Git submodules, and really opened my eyes to their power.

Lots of large web apps are built around the idea of  a core product that gets expanded by plugins. A good example of this is Wordpress, which powers more website on the internet than any other publishing platform, including Allison's podfeet.com website!

You can install Wordpress by downloading a ZIP file, expanding it, copying it into a folder on your web server, and editing a single config file to capture some basic information about your web server and web site's configuration, and to connect the code to your database server. This will give you the core Wordpress web app, and no more. You can add additional themes and plugins by downloading their zip files, extracting them, and uploading them into the appropriate sub-folder within the `wp-content` folder in your Wordpress instance.

If you configure the Wordpress with appropriate write permissions to your web server's disk, you can even have Wordpress do plugin and theme installs for you, but you're just automating the same process. Once you've given Wordpress write permissions to your web server you can even configure it to keep your plugins updated automatically!

Setting up Wordpress like this works great for small sites, but this setup has some drawbacks, and it won't scale.

Firstly, this entire setup rests on a tradeoff that makes perfect sense for small users — giving any web app write permission on your web server is inherently dangerous because the app can transform itself into literally any app it likes. You are trusting that the update mechanism is secure, otherwise, your website will inevitably be taken over and converted into something nasty. But, in exchange for accepting that risk, you have freed yourself of the chore of keeping your Wordpress install and all your Wordpress plugins patched. And, an un-patched Wordpress site is even more likely to get taken over than a fully patched one with the power to write to disk.

When you use Wordpress in a corporate environment (enterprise, education, publishing, non-profit foundation …) you need to do things differently.

Firstly — you can't accept the risk of granting write access to your web server, so you'll need your IT Department to take over responsibility for patching your site and your entire suite of plugins.

Secondly, you'll need to scale out as well as up. Scaling up is throwing more resources at a single server, scaling out is adding more servers. When you scale out you need to keep the code running on each server in the cluster **identical**, so you can't have each one updating its copy of Wordpress and each plugin autonomously, it has to be done in a synchronised and controlled way.

Thirdly, if your Wordpress instance forms a core part of your business, you'll need to test your updates before you deploy them. This means you won't only have multiple production servers that need to kept in perfect sync, you'll also have one or more staging servers where updates get tested before being *pushed* to production.

You can do all this work without Git, but it can all be done so much more easily with Git, if, and only if, you can nest Git repositories, in other words, if, and only if, you make use of Git submodules!

#### How Submodules Help

What we really need is a way to capture and version not just the current state of our copy of Wordpress, but the current state of our copy of Wordpress, our config file, and the current state of all of our plugins in one Git commit.

What you need is that when you check out a specific Git branch of commit your entire Wordpress folder snaps into a known state with a specific version of Wordpress, a specific revision of your config, and a specific version of each and every theme & plugin.

The recipe to get here goes something like this:

1. Create a Git repo with two branches you will keep permanently:
   1. `main` — this will be the production version on your site's code that gets automatically deployed to all product web servers in the cluster
   2. `staging` — this will be the version of your site that gets automatically deployed to your test server(s)
2. Add the official Wordpress Git repo as a remote named `upstream`.
3. Check out your desired version of Wordpress from the `upstream` remote into your `staging` branch
4. Add your config file, and commit
5. Add a sub-module for each theme and plugin, checking out the exact version of each you want, and commit again.
6. Push your local `staging` branch to your Git server to trigger a deployment to your test servers, and make sure it all works.
7. Merge your `staging` branch into your `main` branch and push again, triggering a deployment to your production servers.

This assumes your sysadmins have used Git's trigger features to handle the work of actually deploying the code to the server, and making any needed substitutions to tweak the config for staging and production environments, but this is all break-and-butter stuff for sysadmins that get wrapped up in the jargon term *CI-CD* with stands for *Constant Integration-Constant Deployment*, and GitHub Actions are an example of a CI-CD service.

What's very important to note here is that when you deploy your repository to your web servers, they all get the **identical** versions of each of the following:

1. Core Wordpress
2. Your Config
3. Each and every installed theme and plugin

This is already cool, but the real magic comes in how you can now handle updates.

To update core Wordpress you can now follow these basic steps:

1. Create a new WIP branch from your `main` branch and check it out
2. Merge the desired version of Wordpress into your WIP branch from the `upstream` remote, i.e. from the official Wordpress Git repo
3. Merge your WIP branch into your `staging` branch and push to trigger a deployment to your test environment
4. Test!
5. Merge your WIP branch into your `main` branch, and push to trigger a deployment to 

This doesn't make obvious use of submodules, but updating themes and plugins in this world does. The process to handle theme and plugin updates now becomes:

1. Create a new WIP branch from your `main` branch and check it out
2. For each theme and plugin you want to update, repeat the following:
   1. Change into the relevant folder — the `git` command is now interacting with a separate mini Git repo inside your main Git repo, and that mini Git repo has the official Git repo for the theme/plugin as it's default remote named `origin`
   2. Fetch all new commits, tags, and branches from the theme/plugin's official Github repo with a `git fetch`
   3. Check out the desired branch, tag, or commit into the mini sub-repo
3. Change back to the root of your main Git repo, and commit — this captures the new desired state for each theme and plugin you updated
4. Merge your WIP branch into your `staging` branch and push to trigger a deployment to your test servers
5. Test!
6. Merge your WIP branch into our `main` brach and push to trigger a deployment to your live website

Finally, let's look at how easy it is to add another web server to your production or testing cluster — all you need to do is check out either your `main` or `staging` branch and you have a full copy of your site's entire codebase ready to go!

With my work hat on I never did this with Wordpress, but it did completely change how I worked with a different, even bigger web app with even more plugins — the open source Virtual Learning Environment Moodle. I started my sysadmin career manually managing a Moodle deployment by downloading and extracting ZIP files and then using things like `rsync` to move files around, and when I transitioned away from being a sysadmin to become a cybersecurity specialist a little over two decades later, I was managing the same Moodle instance via Git with submodules. Wow, what a difference!

### Use-Case 2 — Breaking up a Document Repository

TO DO

### Use-Case 3 — Including Dependencies in an App

TO DO

## Final Thoughts

TO DO
