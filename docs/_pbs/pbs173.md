---
title: Working with Submodules
instalment: 173
miniseries: Git
creators: [bart, allison]
date: 2024-11-09
---
In [the previous instalment](./pbs172) we learned about the concept of Git Submodules and we explored some common use-cases to whet your appetite, but we didn't learn how to actually use them. In this instalment we'll take that next step, and simulate one of the common use-cases — incorporating private shared code into multiple projects.

## Matching Podcast Episode

TO DO

## A Note on Default Git Security Settings

Modern versions of Git block the use of relative paths as Git URLs for Git commands that are triggered by other Git commands rather than directly by a human. In our examples today we'll be using local folders as Git repositories, and because of how Git submodules work, that means the default forms of some of the commands we'll be using will give the following fatal error:

```
fatal: transport 'file' not allowed
```

Note that **this will not happen when using remote repositories over SSH or HTTPS**, so in the real-world you're unlikely to run into this problem.

If you are going to use local folders as Git submodules on an on-going basis you can add a permanent secutiry exception for the currently logged in user with the follow `git config` command:

```sh
# WARNING - THIS ADDS A PERMANENT SECURITY EXCEPTION
git config --global protocol.file.allow always
```

However, this is not recommnened — Git's security defaults were added for a reason!

To avoid advising users to add an unsafe default just to play along with our examples, we'll be taking a different approach — we'll use the `-c` option to over-ride the default setting on a per-command basis. This will make our commands a little longer than they would be in the real world, but it is more secure. Specifically, we'll be adding the following to some commands as needed:

```sh
# only needed when working with local repos, NOT NEEDED FOR SSH/HTTPS remote repos
-c protocol.file.allow=always
```

## Our Overall Scenario — A Small Web App Business

To explore Git submodules we're going to pretend to be a fledgeling business that builds web apps, all of which share the company's branding.

To keep things consistent across current and future apps, the branding is versioned in its own private Git repository named `pbscorp-brand`. Each web app has its own repo, with names like `pbscorp-app1`.  The app repos link the brand repo in as a git submodule.

To play along, start by downloading the instalment ZIP file, extracting it, and opening a terminal in the extracted folder, and executing the initialisation script `initPBS173Demo.sh` with the commands:

```sh
chmod +x *.sh; ./initPBS173Demo.sh
```

This script does the following:

1. Creates three parent folders to simulate Git repositories on three different computers:
   1. `remote-repos` to represent the company's GIT server
   2. `pc-app1Dev` to represent the PC of a newly hired developer who's just been assigned to app 1
   3. `pc-app2Dev` to represent the PC of a developer tasked with creating the brand new app 2
   4. `pc-brandDesigner` to represent the PC of a designer tasked with maintaining the brand
2. Expands the bundled repos `pbscorp-brand.bundle` and `pbscorp-app1.bundle` into the repositories `pbscorp-brand` & `pbscorp-app1` in the `remote-repos` folder

## Scenario 1 — A New Developer on the App 1 Team



## Scenario 2 — Starting App 2



## Scenario 3 — Updating the Brand



## Final Thoughts

TO DO
