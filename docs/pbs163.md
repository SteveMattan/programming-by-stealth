## PBS 163 of X — jq: Lookups & Records

TO DO

## Matching Podcast Episode

TO DO

## Installment Resources

* The instalment ZIP file — [pbs163.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs163.zip) TO CREATE

## PBS 162 Challenge Solution

The challenge set at the end of the previous instalment was simply to generate an alphabetically sorted list of Nobel Laureates, and for bonus credit, to sort the humans by surname rather than first name.

Let's start with my sample solution for the basic question, which you'll find in the instalment ZIP as `pbs162-challengeSolution-basic.jq`:

```jq
# Build an alphabetically sorted list of Nobel Prize winners.
# Input:    JSON as published by the Nobel Committee
# Output:   a array of strings

# get all the laurete names
[
    # explode the prizes
    .prizes[]

    # explode the laureats
    | .laureates[]?

    # build and extract the display names
    | ([.firstname, .surname // empty] | join(" "))
]

# sort and de-duplicate the names
# (note that the unique function sorts as well as deduplicates)
| unique
```

As you can see, I first built a list with all laureate names by exploding the prizes array, then exploding the laureates arrays within those, and then extracting the names using the same logic from the previous challenge to deal sensibly with the fact that organisations only have a first name. All of this is wrapped in a set of square brackets to collect the names into an array.

This array of all the names is not sorted, and it definitely contains duplicates, since there were quite a number of repeat winners. We can take care of both of these problems in one step by simply piping the array through the `unique` function which both deduplicates and sorts arrays.

To get the bonus credit we we needed to sort on one value, and display another. My approach was to start similarly to the basic solution, by getting all the laureates, but instead of extracting the names, I added two new keys to each of their dictionaries — one with the desired display name, the other with the string to sort on. You'll find my solution in the instalment ZIP as `pbs162-challengeSolution-bonusCredit.jq`:

```jq
# Build an alphabetically sorted list of Nobel Prize winners.
# Human winners are sorted on surname, organisations on organisation name.
# Input:    JSON as published by the Nobel Committee
# Output:   a array of strings

# get all the lauretes
[
    # explode the prizes
    .prizes[]

    # explode the laureats
    | .laureates[]?

    # add a field to support sorting
    | .sortBy = ((select(has("surname")) | "\(.surname) \(.firstname)" ) // .firstname)

    # add a field for the name to display
    | .displayName = ([.firstname, .surname // empty] | join(" "))
]

# deduplicate first, or the sorting will get broken
| unique_by(.displayName)

# sort the array on the sortBy key
| sort_by(.sortBy)

# extract the display names
| [
    # re-explode the laureats
    .[]

    # extract just the display name
    | .displayName
]
```

Notice that once I have my array of laureate dictionaries, with their two new keys `sortBy` and `displayName`, I first deduplicate them by their display name with `unique_by`, then I sort them by the key I added for that purpose, and only then, when the array of dictionaries is in the right order do I explode it, extract the display name, and re-assemble just those strings into the final array.

Finally, I want to draw attention to how I chose to build the `sortBy` key:

```jq
.sortBy = ((select(has("surname")) | "\(.surname) \(.firstname)" ) // .firstname)
```

This makes use of the fact that the `select` function returns either `empty` or the full dictionary it was passed, and that the alternate operator (`//`) only actions the right-hand-side if the left hand side returns `empty`, `null` or `false`. So, if there is no surname, then the select emits zero dictionaries to the pipe to its right, so no string gets constructed, and the left-hand-side evaluates to `empty`, so the right-hand-side is executed, and that value gets assigned to `.sortBy`.

## 'Types' of Dictionary

Dictionaries are very flexible data structures, they can be used to achieve many different ends. This is why computer scientists use conceptual terms like 'record' and 'lookup' to describe different ways dictionaries are used to reprsent data. These are not rigorously defined terms, but loose concepts. For our purposes I want to describe two of those broad concepts — records and lookups.

### Records

Consider an updated version of the `menu.json` file we've used for many of our examples in recent instalments (I've added scones):

```json
[
	{
		"name": "hotdogs",
		"price": 5.99,
		"stock": 143
	},
	{
		"name": "pancakes",
		"price": 3.10,
		"stock": 43
	},
	{
		"name": "waffles",
		"price": 7.50,
		"stock": 14
	},
	{
		"name": "scones",
		"price": 7.50,
		"stock": 11
	}
]
```

This file contains and array of dictionaries, each defining the same keys. This JSON perfectly describes a traditional table with the keys defining the columns, and each dictionary, a row in the table, or a *'record'*.

In other words, arrays of dictionaries with the same keys can be thought of as records in a traditional database table or rows in a spreadsheet.

To illustrate the point, here's the table the file represents:

| name     | price | stock |
| -------- | ----- | ----- |
| hotdogs  | 5.99  | 143   |
| pancakes | 3.10  | 43    |
| waffles  | 7.50  | 14    |
| scones   | 7.50  | 11    |

So, when the values of the keys in a dictionary map to the names of columns in a conceptual table, we call those dictionaries *records*.

### The Space/Time Tradeoff

Arrays of record-style dictionaries are the least space-inefficient means of storing tabular data in JSON, so you'll see them a lot. But, they're very inefficient to search. The only way to find the details in a specific record is to loop over the array of dictionaries. In more traditional programming languages we literally use looping constructs like `for`, `while`, or `foreach`, but in jq we effectively do the same in less ways by exploding arrays and piping the pieces through the `select` function.

When you have small data sets you query just once this inefficiency is negligible, but for larger data sets searched often things go downhill fast, both in terms of processing time and code complexity. Lots of loops or lots of calls to `select` make for difficult to maintain code!

Is there a way to speed up the processing? Of course there is, but it will come with trade offs — we're inevitably forced to use space to buy time! We can use the space in RAM or on disk, but something always has to give!

In the world of databases, you trade space for time by adding little mini-tables to your tables called *indexes* which map column values to row numbers, so you can use and index on, say the `name` column to near instantly look up the row number for the record with the name `hotdog`. Indexes take time to build and update, and disk space to store, so you trade cpu time to manage the index each time you add or update a record, and disk space to store the index, in exchange for saving CPU time each time you need to search the table.

when you're working with JSON data there are no tables or indexes, just arrays and dictionaries, so you need to build index-like data structure from those pieces, and that's where lookup-type dictionaries come in.

### Lookups

A lookup is a dictionary where the keys are the values for the hypothetical column being indexed. In other words, instead of the keys being column headings like `name` and `price` as they are with record-style dictionaries, they are actual names or prices like `hotdog` and `7.50`.

If your keys are now values for a given column, what are your values? They can either be record-style dictionaries, plain values, or arrays of values. Like there is no single right way to index a database table, there is no single right way to create JSON lookups — it varies each time by the nature of the data being stored, and kinds of queries you need to perform against it. Designing efficient data structures, be that database tables and indexes or JSON, is a skill, and the only way to learn is to make 10,000 mistakes!

My approach is to leave the structure of the JSON data I receive as-is unless and until I find myself thinking *"this is really hard to search"*, then I think about how to build one or more lookups to splify things.

First, the most generic kind of lookup simply indexes records by that most important key, what database people would refer to as the table's *primary key*, in the case of our menu that would be the `name`, so a record lookup would look like:

```json
{
  "hotdogs": {
    "name": "hotdogs",
    "price": 5.99,
    "stock": 143
  },
  "pancakes": {
    "name": "pancakes",
    "price": 3.10,
    "stock": 43
  },
  "waffles": {
    "name": "waffles",
    "price": 7.50,
    "stock": 14
  },
  "scones": {
    "name": "scones",
    "price": 7.50,
    "stock": 11
  }
}
```

To save space you could remove the name from the records:

```json
{
  "hotdogs": {
    "price": 5.99,
    "stock": 143
  },
  "pancakes": {
    "price": 3.10,
    "stock": 43
  },
  "waffles": {
    "price": 7.50,
    "stock": 14
  },
  "scones": {
    "price": 7.50,
    "stock": 11
  }
}
```

When you need to read one specific value over and over, you may want a special-purpose lookup, like for example, prices by food:

```json
{
  "hotdogs": 5.99,
  "pancakes": 3.10,
  "waffles": 7.50,
  "scones": 7.50
}
```

There is a one-to-one mapping from name to price, but not all indexes are one-to-one, this is when you need lookups with arrays of values. For example, names indexed by price:

```json
{
  "3.10": [
    "pancakes"
  ],
  "5.99": [
    "hotdogs"
  ],
  "7.50": [
    "waffles",
    "scones"
  ]
}
```


## How jq Approaches Lookups 

Before describing the approach the creators of jq took, I want you to put yourself in their shoes. The problem to be solved is to design a standard jq function that can transform any of the infinity of possible JSON data structures into any of the infinitly many possible lookups. That's quite the complex problem!

Faced with these kinds of complex problems, there are a number of possible avenues open to developers.

One approach is to build a function that takes many possible optional arguments, or, build a large suite of functions, and hope you capture at least most of the possible scenarios most developers will face most of the time. This is how we got the massively complex `find` terminal command which tried to provide an optional argument for most types of searches most users need most of the time. One look at the `man` page for this command makes the trade off with this approach pretty obvious — so much complexity most users just give up! Thankfully this is not the approach the jq developers took.

Another common approach is to invent or adopt a domain-specific language, your functions take just a few arguments, one of which is a string that lets the user express their need in the appropriate domain-specific language. A good example here is the complex problem of pattern matching, where many programming/scripting languages choose to adopt the domain-specific language of regular expressions to simplify their own functions. This is in fact how the jq developers choose to tackle the complex problem of supporting pattern matching — provide a few simple jq functions that expect PCRE-formatted regular expressions as arguments. This is not how they chose to handle the lookup problem though, and with very good reason — there is no equivalent widely used domain-specific language for describing mappings between data structures and lookups.

The commonly used approach the jq developers did choose is to use a simple, well defined *intermediate data format*. Instead of one or more complex functions that go straight from any possible JSON input to any possible lookup, make users transform the JSON into a simple and clearly defined data structure first, and then pipe that to a very simple jq function. This is a great solution for jq, because transforming JSON is what jq is all about!

### jq 'Entries'

The intermediate format jq's lookup-related functions use is a simple array of dictionaries, which the documentation describe as *entries*. A list of *entries* is an array of dictionaries containing exactly two keys — one named `key`, and one named `value`, each describing one key-value pair, or entry, in a lookup.

For example, we could represent our price lookup by name as the following list of entries:

```json
[
  {
    "key": "hotdogs",
    "value": 5.99
  },
  {
    "key": "pancakes",
    "value": 3.10
  },
  {
    "key": "waffles",
    "value": 7.50
  },
  {
    "key": "scones",
    "value": 7.50
  }
]
```



## Building Lookups

TO DO 

### One-to-One Lookups with `from_entries`

TO DO

Example — create entries list for price lookup

```sh
jq '[.[] | {key: .name, value: .price}]' menu.json
```

TO DO

Example — create price lookup by name:

```sh
jq '[.[] | {key: .name, value: .price}] | from_entries' menu.json
```

TO DO

Example — create records lookup by name:

```sh
# full records
jq '[.[] | {key: .name, value: .}] | from_entries' menu.json

# records with name removed
jq '[.[] | {key: .name, value: .} | del(.value.name)] | from_entries' menu.json
```

### One-to-Many Lookups with the Help of `group_by`

TO DO

Example — create name lookup by non-unique key price:

```sh
jq 'group_by(.price) | [.[] | {key: (.[0].price | tostring), value: [.[] | .name]}] | from_entries' menu.json
```

## EPISODE BREAK??? — Disassembling and Re-Indexing Lookups

TO DO

### Converting Lookups to Records with `to_entries`

TO DO

Good example is JSON returned by HIBP

```sh
jq '.Breaches | to_entries | [ .[] | select(.key | startswith("bob")) ] | from_entries' hibp.json
```

### Re-indexing Lookups

TO DO

TO DO — Example???

## An Optional Challenge

TO DO

## Final Thoughts

TO DO
