# PBS 152 of X — Bash: xargs & Easier Arithmetic

While developing my sample solution to the challenge set at the end of the previous instalment I found myself running into three pain-points, and it so happens that addressing them in this instalment and the next fits in perfectly into the bigger arc of our shell scripting journey.

The two pain points we'll focus on today fell out of my simple desire to use the ASCII characters for drawing pretty tables to frame my table. To do that I needed to know the maximum length of each column, and doing that reliably required a lot of character counting and arithmetic.

To do the character counting efficiently, I needed to make use of an extremely useful terminal command that's simultaneously extremely simple, and extremely confusing! I've been dreading trying to explain it, but now is the time, prepare to meet `xargs`!

After that heavy lifting we'll move on to doing arithmetic in a cleaner and simpler way than piping strings through the `bc` (basic calculator) command.

The final pain point — copying and pasting code, that will be the main focus of the next instalment, POSIX functions, and, the very much related topic of variable scope in Bash.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file — [pbs152.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs152.zip)

## PBS 151 Challenge Solution

The challenge set at the end of the previous instalment was to write a script to render multiplication tables in a nicely formatted table. The script was to take the number it should do the tables for as a required argument, default to rending the table from 1 to 10, and allow optional named arguments `-m` and `-M` for custom minimum and maximum values. There was also bonus credit for outputting the table through `less` if and only if the output was going to a terminal.

On reflection, I should not have been thinking *minimum* and *maximum*, but *start* and *end*, so I changed the spec for my sample solution to:

> Write a script that renders the multiplication tables for a given number. By default the table should start at 1 and run to 10. The script should:
>
> 1. Require one argument — the number to render the table for
> 2. Accept the following two optional arguments:
>  	* `-s` to specify a custom starting value, replacing the default of `1`
> 	    * `-e` to specify a custom ending value, replacing the default of `10`

Because I needed it to save my own sanity while trying to debug my sample solution, I also added an extra feature not in the requirements, a `-d` flag to enable debug output to `STDERR`.

You'll find the full code for my sample solution in the file `pbs151-challengeSolution.sh` in the instalment ZIP:

```bash
#!/usr/bin/env bash

# Exit codes:
# 1: missing required args or unsupported flags or optional args
# 2: invalid value for supported arg

#
# === set defaults ===
#
start=1    # default to starting at 1
end=10     # default to ending at 10
doDebug='' # default to not debugging

#
# === process args ===
#

# utility variables
usage="Usage: $(basename $0) [-s START] [-e END] [-d] N"
intRE='^-?[0-9]+$'

# process optional args & flags
while getopts ':s:e:d' opt
do
    case $opt in
        s)  
            if echo "$OPTARG" | egrep -q "$intRE"
            then
                start=$OPTARG
            else
                echo "invalid starting value '$OPTARG', must be a whole number" >&2
                echo "$usage" >&2
                exit 2
            fi
            ;;
        e)
            if echo "$OPTARG" | egrep -q "$intRE"
            then
                end=$OPTARG
            else
                echo "invalid ending value '$OPTARG', must be a whole number" >&2
                echo "$usage" >&2
                exit 2
            fi
            ;;
        d)
            doDebug=1
            ;;
        ?)
            echo "$usage" >&2
            exit 1
            ;;
    esac
done
shift $(echo "$OPTIND-1" | bc)

# process positional arg
n=$1
if [[ -z $n ]] # no first real arg
then
    echo "$usage" >&2
    exit 1
fi
if ! echo "$n" | egrep -q "$intRE" # invalid first real arg
then
    echo "invalid number '$n' first argument must be a whole number" >&2
    exit 2
fi

# if debugging, print values
if [[ -n $doDebug ]]
then
    echo "DEBUG: n       = $n" >&2
    echo "DEBUG: start   = $start" >&2
    echo "DEBUG: end     = $end" >&2
fi

#
# === Build row format string ===
#

# calculate maximum lengths for each column when nicely formatted
nLen=$(printf "%'d" $n | wc -c | xargs) # character length of the number when formatted
maxMLen=1 # maximum character length of any formatted multiplier
maxPLen=1 # maximum character length of any formatted product
for m in $(seq $start $end)
do
    # Multiplier length when nicely formatted
    mLen=$(printf "%'d" $m | wc -c | xargs)
    [[ $mLen -gt $maxMLen ]] && maxMLen=$mLen

    # Product length when nicely formatted
    pLen=$(echo "$n*$m" | bc | xargs printf "%'d" | wc -c | xargs)
    [[ $pLen -gt $maxPLen ]] && maxPLen=$pLen
done

# calculate the length of the middle piece of the table caps
capLen=$(echo "8+$nLen+$maxMLen+$maxPLen" | bc)

# if debugging, print the calculated numbers
if [[ -n $doDebug ]]
then
    echo "DEBUG: nLen    = $nLen" >&2
    echo "DEBUG: maxMLen = $maxMLen" >&2
    echo "DEBUG: maxPLen = $maxPLen" >&2
    echo "DEBUG: capLen  = $capLen" >&2
fi

# build the row format string, and print if debugging
fString="┃ %'"$nLen"d x %'"$maxMLen"d = %'"$maxPLen"d ┃\n"
[[ -n $doDebug ]] && echo "DEBUG: fString = $fString" >&2

# build the cap insert, and print if debugging
capMid=''; for c in $(seq 1 $capLen); do capMid+='━'; done
[[ -n $doDebug ]] && echo "DEBUG: capMid  = $capMid" >&2

#
# === print the table ===
#

# the variable to build the table into
table=''

# render the top cap row
printf -v row '┏%s┓\n' $capMid
table+=$row

# print the table body
for m in $(seq $start $end)
do
    # calculate the product
    p=$(echo "$n*$m" | bc)

    # render the table row
    printf -v row "$fString" $n $m $p
    table+=$row
done

# render the bottom cap row
printf -v row '┗%s┛\n' $capMid
table+=$row

# print the table
if [[ -t 1 ]]
then
    echo "$table" | less --no-init --quit-if-one-screen
else
    echo "$table"
fi
```

You can see the three-times tables by running the script with the argument `3`:

```bash
./pbs151-challengeSolution.sh 3
```

This sample solution is really quite long indeed, and the majority of the code is using concepts that we've been using heavily in recent instalments, so I won't go through it line-by-line, but I do want to draw your attention to a few important points.

### Enabling Easier Debugging

I want to start by pointing out some features I added to make the script easier to debug. Up to this point in this series-within-a-series our scripts have been too simplistic to warrant this kind of software engineering effort, but in the real world I do these kinds of things all even moderately complex coding tasks.

Firstly, if a script can fail for multiple reasons, assign different exit codes to each reason, and document them clearly. Notice that my sample solution terminates with an exit code of 1 when the user passes an incorrect set of arguments, and an exit code of 2 if they pass a valid set of arguments containing and invalid value for one or more of those arguments. And, notice the clear comments at the top of the script describing these exit codes:

```bash
# Exit codes:
# 1: missing required args or unsupported flags or optional args
# 2: invalid value for supported arg
```

If you run the script without the minimum needed single argument you can see it exits with 1 by running the script that way, then printing the special POSIX variable `$?` to show the most recent exit code:

```
./pbs151-challengeSolution.sh
echo $?
```

If you pass an invalid number, you get an exit code of 2:

```bash
./pbs151-challengeSolution.sh pancakes
echo $?
```

Secondly, when you're working on code of any kind you often want more detailed feedback than you'll want when the code is being used for real. What would be infuriating noise in real use is invaluable insight when developing! You can eat your proverbial cake and still have it by adding a flag to put your code into debug mode.

I chose to use an optional `-d` flag to enable debug mode:

```bash
./pbs151-challengeSolution.sh -d 3
```

To implement this I used a variable named `$doDebug` with a default value of an empty string. Debug messages only get printed when this variable is not an empty string. This approach allows me to use the `-n` operator to test for debug mode (see the code snippets below).

Another point of note is that it's best to keep debug messages separate from code's true output. This is why I chose to write all debug messages to `STDERR`.

This gives you the power to redirect debug and regular messages separately:

```bash
# save debug messages to a log file
./pbs151-challengeSolution.sh -d 3 2>debug.log

# see only debug messages (STDOUT to /dev/null)
./pbs151-challengeSolution.sh -d 3 >/dev/null
```

Putting it all together, these code snippets show how I implemented debugging support:

```bash
while getopts ':s:e:d' opt
do
    case $opt in
        # …
        d)
            doDebug=1
            ;;
		# …
    esac
done

# …

# if debugging, print values
if [[ -n $doDebug ]]
then
    echo "DEBUG: n       = $n" >&2
    echo "DEBUG: start   = $start" >&2
    echo "DEBUG: end     = $end" >&2
fi
```

### Pretty ASCII Tables

Before GUIs became popular, text-only interface could draw nice tables. This is because even old text encoding schemes like ASCII made use for a set of characters that form the parts of a table, including corners and junctions. You can see and copy these characters using your OS's character viewer.

You'll see them in use throughout my templating strings.

### Calculating Widths

LEFT OFF HERE!!!

## Introducing `xargs`

TO DO

## Arithmetic Expressions in Bash

TO DO

## Final Thoughts

TO DO

### An Optional Challenge

TO REVIEW AND PERHAPS EXPAND

Update your sollution to the previous challenge to use Bash arithmetic instead of the `bc` command.
