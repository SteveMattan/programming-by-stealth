# PBS 152 of X — Bash: xargs & Easier Arithmetic

While developing my sample solution to the challenge set at the end of the previous instalment I found myself running into three pain-points, and it so happens that addressing them in this instalment and the next fits in perfectly into the bigger arc of our shell scripting journey.

The two pain points we'll focus on today fell out of my simple desire to use the ASCII characters for drawing pretty tables to frame my table. To do that I needed to know the maximum length of each column, and doing that reliably required a lot of character counting and arithmetic.

To do the character counting efficiently, I needed to make use of an extremely useful terminal command that's simultaneously extremely simple, and extremely confusing! I've been dreading trying to explain it, but now is the time, prepare to meet `xargs`!

After that heavy lifting we'll move on to doing arithmetic in a cleaner and simpler way than piping strings through the `bc` (basic calculator) command.

The final pain point — copying and pasting code, that will be the main focus of the next instalment, POSIX functions, and, the very much related topic of variable scope in Bash.

## Matching Podcast Episode

TO DO

## Episode Resources

TO UPDATE

* The instalment ZIP file — [pbs152.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs152.zip)

## PBS 151 Challenge Solution

The challenge set at the end of the previous instalment was to write a script to render multiplication tables in a nicely formatted table. The script was to take the number it should do the tables for as a required argument, default to rending the table from 1 to 10, and allow optional named arguments `-m` and `-M` for custom minimum and maximum values. There was also bonus credit for outputting the table through `less` if and only if the output was going to a terminal.

On reflection, I should not have been thinking *minimum* and *maximum*, but *start* and *end*, so I changed the spec for my sample solution to:

> Write a script that renders the multiplication tables for a given number. By default the table should start at 1 and run to 10. The script should:
>
> 1. Require one argument — the number to render the table for
> 2. Accept the following two optional arguments:
>  	* `-s` to specify a custom starting value, replacing the default of `1`
> 	    * `-e` to specify a custom ending value, replacing the default of `10`

Because I needed it to save my own sanity while trying to debug my sample solution, I also added an extra feature not in the requirements, a `-d` flag to enable debug output to `STDERR`.

You'll find the full code for my sample solution in the file `pbs151-challengeSolution.sh` in the instalment ZIP:

```bash
#!/usr/bin/env bash

# Exit codes:
# 1: missing required args or unsupported flags or optional args
# 2: invalid value for supported arg

#
# === set defaults ===
#
start=1    # default to starting at 1
end=10     # default to ending at 10
doDebug='' # default to not debugging

#
# === process args ===
#

# utility variables
usage="Usage: $(basename $0) [-s START] [-e END] [-d] N"
intRE='^-?[0-9]+$'

# process optional args & flags
while getopts ':s:e:d' opt
do
    case $opt in
        s)  
            if echo "$OPTARG" | egrep -q "$intRE"
            then
                start=$OPTARG
            else
                echo "invalid starting value '$OPTARG', must be a whole number" >&2
                echo "$usage" >&2
                exit 2
            fi
            ;;
        e)
            if echo "$OPTARG" | egrep -q "$intRE"
            then
                end=$OPTARG
            else
                echo "invalid ending value '$OPTARG', must be a whole number" >&2
                echo "$usage" >&2
                exit 2
            fi
            ;;
        d)
            doDebug=1
            ;;
        ?)
            echo "$usage" >&2
            exit 1
            ;;
    esac
done
shift $(echo "$OPTIND-1" | bc)

# process positional arg
n=$1
if [[ -z $n ]] # no first real arg
then
    echo "$usage" >&2
    exit 1
fi
if ! echo "$n" | egrep -q "$intRE" # invalid first real arg
then
    echo "invalid number '$n' first argument must be a whole number" >&2
    exit 2
fi

# if debugging, print values
if [[ -n $doDebug ]]
then
    echo "DEBUG: n       = $n" >&2
    echo "DEBUG: start   = $start" >&2
    echo "DEBUG: end     = $end" >&2
fi

#
# === Build row format string ===
#

# calculate maximum lengths for each column when nicely formatted
nLen=$(printf "%'d" $n | wc -c | xargs) # character length of the number when formatted
maxMLen=1 # maximum character length of any formatted multiplier
maxPLen=1 # maximum character length of any formatted product
for m in $(seq $start $end)
do
    # Multiplier length when nicely formatted
    mLen=$(printf "%'d" $m | wc -c | xargs)
    [[ $mLen -gt $maxMLen ]] && maxMLen=$mLen

    # Product length when nicely formatted
    pLen=$(echo "$n*$m" | bc | xargs printf "%'d" | wc -c | xargs)
    [[ $pLen -gt $maxPLen ]] && maxPLen=$pLen
done

# calculate the length of the middle piece of the table caps
capLen=$(echo "8+$nLen+$maxMLen+$maxPLen" | bc)

# if debugging, print the calculated numbers
if [[ -n $doDebug ]]
then
    echo "DEBUG: nLen    = $nLen" >&2
    echo "DEBUG: maxMLen = $maxMLen" >&2
    echo "DEBUG: maxPLen = $maxPLen" >&2
    echo "DEBUG: capLen  = $capLen" >&2
fi

# build the row format string, and print if debugging
fString="┃ %'"$nLen"d x %'"$maxMLen"d = %'"$maxPLen"d ┃\n"
[[ -n $doDebug ]] && echo "DEBUG: fString = $fString" >&2

# build the cap insert, and print if debugging
capMid=''; for c in $(seq 1 $capLen); do capMid+='━'; done
[[ -n $doDebug ]] && echo "DEBUG: capMid  = $capMid" >&2

#
# === print the table ===
#

# the variable to build the table into
table=''

# render the top cap row
printf -v row '┏%s┓\n' $capMid
table+=$row

# print the table body
for m in $(seq $start $end)
do
    # calculate the product
    p=$(echo "$n*$m" | bc)

    # render the table row
    printf -v row "$fString" $n $m $p
    table+=$row
done

# render the bottom cap row
printf -v row '┗%s┛\n' $capMid
table+=$row

# print the table
if [[ -t 1 ]]
then
    echo "$table" | less --no-init --quit-if-one-screen
else
    echo "$table"
fi
```

You can see the three-times tables by running the script with the argument `3`:

```bash
./pbs151-challengeSolution.sh 3
```

This sample solution is really quite long indeed, and the majority of the code is using concepts that we've been using heavily in recent instalments, so I won't go through it line-by-line, but I do want to draw your attention to a few important points.

### Enabling Easier Debugging

I want to start by pointing out some features I added to make the script easier to debug. Up to this point in this series-within-a-series our scripts have been too simplistic to warrant this kind of software engineering effort, but in the real world I do these kinds of things all even moderately complex coding tasks.

Firstly, if a script can fail for multiple reasons, assign different exit codes to each reason, and document them clearly. Notice that my sample solution terminates with an exit code of 1 when the user passes an incorrect set of arguments, and an exit code of 2 if they pass a valid set of arguments containing and invalid value for one or more of those arguments. And, notice the clear comments at the top of the script describing these exit codes:

```bash
# Exit codes:
# 1: missing required args or unsupported flags or optional args
# 2: invalid value for supported arg
```

If you run the script without the minimum needed single argument you can see it exits with 1 by running the script that way, then printing the special POSIX variable `$?` to show the most recent exit code:

```
./pbs151-challengeSolution.sh
echo $?
```

If you pass an invalid number, you get an exit code of 2:

```bash
./pbs151-challengeSolution.sh pancakes
echo $?
```

Secondly, when you're working on code of any kind you often want more detailed feedback than you'll want when the code is being used for real. What would be infuriating noise in real use is invaluable insight when developing! You can eat your proverbial cake and still have it by adding a flag to put your code into debug mode.

I chose to use an optional `-d` flag to enable debug mode:

```bash
./pbs151-challengeSolution.sh -d 3
```

To implement this I used a variable named `$doDebug` with a default value of an empty string. Debug messages only get printed when this variable is not an empty string. This approach allows me to use the `-n` operator to test for debug mode (see the code snippets below).

Another point of note is that it's best to keep debug messages separate from code's true output. This is why I chose to write all debug messages to `STDERR`.

This gives you the power to redirect debug and regular messages separately:

```bash
# save debug messages to a log file
./pbs151-challengeSolution.sh -d 3 2>debug.log

# see only debug messages (STDOUT to /dev/null)
./pbs151-challengeSolution.sh -d 3 >/dev/null
```

Putting it all together, these code snippets show how I implemented debugging support:

```bash
while getopts ':s:e:d' opt
do
    case $opt in
        # …
        d)
            doDebug=1
            ;;
		# …
    esac
done

# …

# if debugging, print values
if [[ -n $doDebug ]]
then
    echo "DEBUG: n       = $n" >&2
    echo "DEBUG: start   = $start" >&2
    echo "DEBUG: end     = $end" >&2
fi
```

### Pretty ASCII Tables

Before GUIs became popular, text-only interface could draw nice tables. This is because even old text encoding schemes like ASCII made use for a set of characters that form the parts of a table, including corners and junctions. You can see and copy these characters using your OS's character viewer.

You'll see them in use throughout my templating strings.

### Calculating Widths

Something important to realise is that because we are now using printf to pretty-print our integers, knowing their character length has become much more complicated — it's not simply determined by the order of magnitude and the sign, but by the number of thousand separators needed. I'm sure it's possible to derive a formula to get the answer, but I opted for a much simpler approach — loop over all the numbers in the sequence, pretty print them, and count their length in characters with `wc -c` (*word count* with the character option). This sounds easy to do, but it's actually quite complicated, and to do it efficiently, I needed to utilise the two most common uses of the `xargs` command:

```bash
# calculate maximum lengths for each column when nicely formatted
nLen=$(printf "%'d" $n | wc -c | xargs) # character length of the number when formatted
maxMLen=1 # maximum character length of any formatted multiplier
maxPLen=1 # maximum character length of any formatted product
for m in $(seq $start $end)
do
    # Multiplier length when nicely formatted
    mLen=$(printf "%'d" $m | wc -c | xargs)
    [[ $mLen -gt $maxMLen ]] && maxMLen=$mLen

    # Product length when nicely formatted
    pLen=$(echo "$n*$m" | bc | xargs printf "%'d" | wc -c | xargs)
    [[ $pLen -gt $maxPLen ]] && maxPLen=$pLen
done
``` 

First, note that the overall algorithm is not complex:

1. assume the maximum length of the multiplier and product are both one.
2. loop over all the multipliers in the sequence, and for each one:
	1. calculate the product
	2. calculate the length, in characters when pretty-printed, of both the multiplier and product
	3. for each, check if the newly calculated max length is bigger than the stored max length, and if it is, update the stored max length

The devil is very much in the detail, in calculating the character lengths. Understanding just this one line is key to understanding the power of `xargs`:

```bash
pLen=$(echo "$n*$m" | bc | xargs printf "%'d" | wc -c | xargs)
```

Put a mental pin in this, we'll be breaking it down piece-by-piece in the next section.

Before we get into the weeds of `xargs` I want to focus on two more things.

### Building the Format String

Let's start with the new skill this assignment was intended to test — string formatting with `printf`. Because I wanted my table to have a border on both sides, I needed to be sure each row was exactly the same length. Once I used the loop above to calculate the maximum width of the multiplier and the product, I could combine that with the width of the number being multiplied to built my template:

```bash
fString="┃ %'"$nLen"d x %'"$maxMLen"d = %'"$maxPLen"d ┃\n"
```

My string starts and ends with a space, the ASCII character for a vertical table side, and another space. It then has a format specification for a whole number, a space, an `x`, and another space, an other format specification for an integer, another space, an `=`, and a space, and a final format specifier.

To understand how this string is being built up, it's important to remember that in Bash, placing strings end-to-end concatenates them, so there are actually 7 strings being concatenated:

1. `"┃ %'"`
2. `$nLen`
3. `"d x %'"`
4. `$maxMLen`
5. `"d = %'"`
6. `$maxPLen`
7. `"d ┃\n"`

If we imagine `$nLen` is `1`, `$maxMLen` is `2`, and `$maxPLen` is `3`, the format string becomes:

```bash
fString="┃ %'1d x %'2d = %'3d ┃\n"
```

You'll notice each of the three format specifications now take the same form — `%'nd` where `n` is a number. As we learned in the previous instalment, `%d` is a digit, `%'d` is a digit with thousand separators, and `%d'4` is a digit with thousand separators with a minimum length of 4 characters, right-aligned.

So, the format string simply breaks down to a table edge, a column with the original number with a thousand separator and a minimum length of it's actual length, a multiplication symbol, the number the original is being multiplied by with a thousand separator and a minimum length of the longest such number in the table, an equals sign, the product of the multiplication with a thousand separator and a minimum width of the widest product, and the other edge of the table.

### Conditionally Paging the Output

The final thing I want to draw your attention to before we get back to `xargs` is the conditional automatic paging of the output. In other words, if the output is longer than one screen, and if the output is being written to a terminal, present the output to the user one page at a time using the `less` command.

Rather than printing my table directly, I build it up by appending each row to a string named `$table`, then, at the end of the script, I check to see whether or not the output is a terminal, and then I either write directly to standard out, or, I pipe my table through `less`:

```bash
# print the table
if [[ -t 1 ]]
then
    echo "$table" | less --no-init --quit-if-one-screen
else
    echo "$table"
fi
```

As we learned in the previous instalment, the `-t n` operator tests if the stream number `n` is a terminal or not. Standard out is always numbered `1`, hence the `if` statement above.

In my English description I said I only wanted to route the output through `less` if it was going to the terminal **and** longer than one screen, but the code does something subtly different that has the same apparent effect. The code always send the output through `less`, but it uses two important flags to tell `less` to adopt our desired behaviour.

Before looking at the flags, let's remind ourselves what `less` does by default:

```bash
echo -e "hello\nworld" | less
```

What happens? Less scrolls the screen so our two lines appear at the very bottom, it pauses there and blocks the script until we press `q` to exit, and when we do exit, it deletes the content it wrote to the screen. We don't want it to do any of that!

Firstly, we can stop it waiting for the key press when there is less than a full page of content with the `--quit-if-one-screen` flag:

```bash
echo -e "hello\nworld" | less --quit-if-one-screen
```

That now works perfectly when there is less than a full screen of text. But what if there is more than one screen of text?

```bash
seq 1 100 | less --quit-if-one-screen --no-init
```

Initially this seems to work — we get the numbers from 1 to 100 one screen at a time, but when we get to the end **all the numbers vanish!** By default, `less` cleans up the screen when it pages. We can stop it doing that with the `--no-init` flag:

```bash
seq 1 5 | less --quit-if-one-screen --no-init
```

In case you're wondering how I knew these obscure flags for `less`, I didn't! As soon as I saw the ways the default behaviour was not what I wanted, I read the manual pages with `man less` 🙂

## Introducing `xargs`

TO DO — LEFT OFF HERE!!!

## Arithmetic Expressions in Bash

TO DO

## Final Thoughts

TO DO

### An Optional Challenge

TO REVIEW AND PERHAPS EXPAND

Update your solution to the previous challenge to use Bash arithmetic instead of the `bc` command.
