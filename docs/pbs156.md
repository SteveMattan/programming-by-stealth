# PBS 156 of X — Extracting Data with `jq`

In [the previous instalment](./pbs155) we got a glimpse of what jq can do, and we looked at some examples of `jq` in action, but we didn't explain the code in any of the filters. We did draw attention to how dense the language was, and how much opportunity there is for confusion. In an attempt to avoid confusion, we're going to learn the jq language in a slow and incremental way, building on our knowledge as we go.

We're going to start our jq journey today by exploring how we can use `jq` to extract specific pieces of information from JSON files.

## Matching Podcast Episodes

TO DO

## Episode Resources

* The instalment ZIP file TO UPDATE — [pbs156.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs156.zip)

## It Starts with `.`

In jq, a leading period (`.`) represents *the item currently being processed*.

So, the jq filter `'.'` simply means the entire input.

Generally speaking, a JSON data structure has a top-level element that is a dictionary or an array, so to extract a specific piece of data, we need to descend into the current item, which we do by adding extra syntax to the right of the leading dot.

## Descending into Dictionaries

To access a given property in a dictionary we simply use its name.

In the instalment ZIP you'll find an example NPM package information file (`this-ti.me-package.json`), which has a dictionary as the top-level element. We can access the value for the key-value pair with the key `name` with the jq filter `'.name'`:

```bash
jq '.name' this-ti.me-package.json
```

If a dictionary contains more dictionaries we can keep descending down key by key by concatenating the keys with further dots. For example, in the sample NPM package file the top-level key `bugs` has a value that's also a dictionary which contains the key `url`, we can access that key's value with the jq filter `'.bugs.url'`:

```bash
jq '.bugs.url' this-ti.me-package.json
```

This basic syntax works great when the keys are free from special characters, but what if the keys have spaces or other special characters in them? In that case, we need to double-quote the key name. As an example, the `dependencies` key in the example NPM package file has a value that is another dictionary, and it has many key-value pairs with special characters in their key name, we can access them all by double-quoting the key names, e.g.:

```bash
jq '.dependencies."is-it-check"' this-ti.me-package.json
jq '.dependencies."@fortawesome/fontawesome-free"' this-ti.me-package.json
```

## Descending into Arrays

To descend into an array, the syntax is very Javascript-like — append a numeric index wrapped by square brackets. Note that indexes start at zero as is the norm for programming languages.

In the instalment ZIP you'll find a JSON data file holding information on all the Nobel prizes (`NobelPrizes.json`). The file is structured as a dictionary defining a single key, `prizes` which is an array of dictionaries, one for each prize. The array is sorted in reverse-chronological order, so the most recent prize is the first item in the array, we can access this most recent prise with the following command:

```bash
jq '.prizes[0]' NobelPrizes.json
```

A nice extra feature offered by jq is negative indexes to count from the end of the array, with `-1` being the last element, `-2` the second last etc..

Using our Nobel prizes database again, we can get the first ever prize with the command:

```bash
jq '.prizes[-1]' NobelPrizes.json
```

## Output Un-Quoted Strings

By default, `jq` outputs all values in JSON syntax. For data structures, i.e. arrays and dictionaries, it’s difficult to see what  else `jq` could do, but for single values the default behaviour can cause problems with strings.

The JSON for booleans and numbers are indistinguishable from  strings from the shell’s point of view, but JSON strings are wrapped in double quotation marks, which are often unwanted when using the output from `jq` in shell scripts or on the command line. 

This is where the `--raw-output` or `-r` flag comes into play.

As an example, let's switch back to our example NPM package file, and extract the author using `jq`'s defaults:

```bash
jq '.author' this-ti.me-package.json
```

If we try to use this in another terminal command we soon realise those quotation marks are not what we want:

```bash
echo "Check out this cool tool by $(jq '.author' this-ti.me-package.json)"
```

This outputs the follow, which makes it look like I'm not the real author or something (ironic quotes):

```text
Check out this cool tool by "Bart Busschots"
```

To remove the quotes we can add the `-r` flag:

```bash
echo "Check out this cool tool by $(jq -r '.author' this-ti.me-package.json)"
```

Now we get the output we want:

```text
Check out this cool tool by Bart Busschots
```



## `jq` Works in Parallel

If you pass `jq` input with multiple top-level JSON items, whether that be from `STDIN`, from a single file, or from multiple files, `jq` runs its filter on each separately, and outputs all the answers on separate lines.

In the instalment folder you'll find two JSON files containing IP information, one for `bartb.ie` (`ip-bartb.json`), and one for `podfeet.com` (`ip-podfeet.json`), both contain a single JSON dictionary.

If we pipe both of these files into `jq` we'll see that it outputs one dictionary after the other with nothing but a newline character separating the end of the first dictionary form the start of the second:

```bash
cat ip* | jq
```

If we add a jq filter to extract the continent code we'll see we get two strings, one for each top-level JSON item in the input. The command:

```bash
cat ip* | jq '.continentCode'
```

Produces the output:

```text
"EU"
"AM"
```

Sometimes it’s useful to automatically combine all the inputs into a single top-level JSON object so the filter only gets applied once, you can use the `—slurp` or `-s` flag to do that.

We can see that if we slurp our two IP details JSON files into `jq` we now get a single output which is an array containing the objects from both files:

```bash
cat ip* | jq -s
```

## Exploding Arrays

As well as the `jq` command supporting parallel processing, jq filters can convert a single input into multiple outputs. We’ll learn more about this later in the series, but a relevant first example is converting a single array to multiple values, one for each element of the array.

The syntax to explode an array into multiple values in jq is to append a pair of square brackets with nothing inside them.

Switching back to our example NPM package file, we can explode the array of keywords into separate values with the command:

```bash
jq '.keywords[]' this-ti.me-package.json
```

This produces the output:

```text
"JavaScript"
"timezones"
```

## Final Thoughts

We’ve now seen how to use jq filters to reach into JSON data structures and extract specific pieces of information. We’ve also seen that the `jq` command can process multiple inputs in parallel, and produce multiple outputs. More than that, we’ve seen that jq filters can expand single inputs into multiple outputs.

This support for parallelism is critical to the next conceptual leaps — jq filter chaining, and jq functions. These are the next concepts we’ll be exploring in the series.
