# PBS 158 of X â€” jq: More Queries

In [the previous instalment](./pbs157) we learned about jq literal values, operators, and functions so we could learn to query JSON files for data matching given criteria using the `select()` function. In this instalment we'll mirror the structure of the previous instalment somewhat, starting with some functions related to data types, then we'll learn about one new operator, and then we'll move on to Jq's support for using regular expressions to search JSON.

## Matching Podcast Episode

TO DO

## Episode Resources

* The instalment ZIP file TO UPDATE â€” [pbs158.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs158.zip)

## PBS 157 Challenge Solutions

At the end of the previous instalment I offered some optional challenges to get some practice querying JSON with the `jq` command. All the challenges involved querying the Nobel Prises data set we've been using in our examples throughout this mini series.

### Question 1 â€” Dr. Ghez's Prize

> "What prize did friend of the NosillaCast podcast Dr. Andrea Ghez win? List the year, category, and motivation."

```bash
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | .year, .category, (.laureates[] | select(.surname == "Ghez") | .motivation)' NobelPrizes.json
```

The first thing I want to draw your attention to is the use of the combination of the `select()` and `any()` functions to query within the `laureates` arrays for each prize without exploding them, ensuring its the entire dictionary for each matching prize that is passed to the next filter in the pipeline by `select`.

Next, note the use of the  `,` (or as we call it the *and also*) operator to separate the multiple filters needed to extract the three requested pieces of data for the matching prize. Finally, note the need to a nested filter chain to extract the final value from within the matching element of the `laureats` array.

### Question 2 â€” Laureates Per Prize

> "How many laureates were there for each prize? List the year, category, and number of winners for each."

```bash
jq '.prizes[] | .year, .category, (.laureates | length )' NobelPrizes.json
```

Note that we don't explode the `laureates` array when calculating its length because the `length` function needs to receive the entire array as a single input.

### Question 3 â€” Single Winner Prizes

> "Which prizes were won outright, i.e. not shared? List the year, category, first name, last name, and motivation for each."

```bash 
jq '.prizes[] | select((.laureates? | length) == 1) | .year, .category, .laureates[0].firstname, .laureates[0].surname, .laureates[0].motivation' NobelPrizes.json
```

Note that because we know there is exactly one winner, we can easily access the details for the laureate using `laureates[0]` to access the first element in the `laureates` array.

## Type-Related jq Functions

As we learned in the previous instalment, jq users the same basic data types as JSON. 

### Determining a Value's Type

We can get the type of a value as a string with the `type` function. The possible return values from `type` are `"null"`, `"boolean"`, `"number"`, `"string"`, `"array"`, and `"object"` (for dictionaries).

### Converting Between Types

We know that our example Nobel Prizes data set wrongly encodes years as strings, and we can now verify that programatically:

```bash
jq '.prizes[0].year | type' NobelPrizes.json # "string"
```

Note that our example data set is by no means alone in this â€” there is a lot of poorly encoded JSON out there!

We also learned that  the equality operator (`==`) uses strict type matching, and that the comparison operators (`<`, `>`, `<=` & `>=`) treat strings and numbers differently, sorting the former alphabetically and the latter numerically.

Let's remind ourselves what these facts mean in practical terms:

```bash
# strings of digits are not the same as numbers
jq -n '2001 == "2001"' # false

# strings get compared alphabetically, even if they are strings of digits
jq -n '"2001" > "23"' # false
```

Given all this it should come as no surprise that jq provides functions for converting between numbers and strings â€”  `tonumber` & `tostring`, and neither take any arguments.

Note that `tonumber` gives an error if it's passed anything but a numeric string.

Let's quickly see these functions in action:

```bash
jq -n '(2001 | tostring) == "2001"' # true
jq -n '2001 == ("2001" | tonumber)' # true

jq -n '("2001" | tonumber) > ("23" | tonumber)' # true

jq -n '"waffles" | tonumber' # throws 'Invalid numeric literal' error
```

### Filtering by Type

To make it easier to skip over items of the wrong type, jq provides a collection of select-like functions that apply a type criteria and either pass the value through, or silently drop it. This pass or drop behaviour is just like what we saw in the previous instalment with `select`.

These functions don't require any arguments since they're basically *'does exactly what it says on the tin'* functions ðŸ˜‰

It's easier to show what these functions do with code snippets than to try describe them. To help us do that we'll use the file `sampleData.json` which contains a top-level array containing entries of different data types:

```json
[
  null,
  true,
  -1,
  0,
  11,
  3.1415,
  "42",
  "waffles",
  [],
  ["dogs", "cats"],
  {},
  {"apples": 12, "pears": 3}
]
```

Let's now use this file to demonstrate the select-like functions `nulls`, `values`, `booleans`, `numbers`, `strings`, `arrays`, `objects`, `iterables` & `scalars` in action:

```bash
# select all nulls (only really useful if you want to check if there are any or count them)
jq '.[] | nulls' sampleData.json
# null

# select everything that's not null
jq '.[] | values' sampleData.json
# true
# -1
# 0
# 11
# 3.1415
# "42"
# "waffles"
# []
# [
#   "dogs",
#   "cats"
# ]
# {}
# {
#   "apples": 12,
#   "pears": 3
# }

# select all booleans
jq '.[] | booleans' sampleData.json
# true

# select all numbers
jq '.[] | numbers' sampleData.json
# -1
# 0
# 11
# 3.1415
# Note: the string "42" is not selected because strict types are used

# select all strings
jq '.[] | strings' sampleData.json
# "42"
# "waffles"

# select all arrays
jq '.[] | arrays' sampleData.json
# []
# [
#   "dogs",
#   "cats"
# ]
# Note: the empty array gets returned

# select all dictionaries
jq '.[] | objects' sampleData.json
# {}
# {
#   "apples": 12,
#   "pears": 3
# }
# Note: the empty dictionary gets returned

# select all things you can loop over (arrays or dictionaries)
jq '.[] | iterables' sampleData.json
# []
# [
#   "dogs",
#   "cats"
# ]
# {}
# {
#   "apples": 12,
#   "pears": 3
# }

# select everything that's a single value (i.e. that you can't loop over)
jq '.[] | scalars' sampleData.json
# null
# true
# -1
# 0
# 11
# 3.1415
# "42"
# "waffles"
```

## The Alternate Operator (`//`)

One of the advantages JSON offers over more rigid data structures like CSV files and traditional relational databases is the flexibility for each piece of data to have a different structure to the others. You can have an array of dictionaries each defining different key-value pairs in JSON, or, you can have the same key map to data of a completely different type from one dictionary to the next.

A very common example is how APIs treat data fields that can have zero, one, or more values. The API may decide to omit the key completely if there are no values for it, add it as a string if there is one value, or an array of strings if there are more values. This is easy for a human to read, but difficult to query with jq because the you need to accommodate the different possibilities without triggering errors.

We have an example of this in the Nobel Prizes dataset we've been using in our examples throughout this series â€” when a Nobel Prize is awarded, the dictionary representing the prize has a key named `laureates` which is an array of dictionaries, each representing a winner, but on the years there was no prize the `laureates` key is completely missing, being replaced instead by a different key named `overallMotivation` which maps to a string explaining what was done with the prize money that was not awarded.

Because alternative structures are so common in JSON, jq provides an operator for handling alternative possibilities, the *alternative operator* `//`. This operator confuses a lot of C, Java, and JavaScript developers because it looks like a comment, but it's not.

The way the operator works is that the filter to the left of the operator is evaluated first, and if it produces any value other than  `null` or `false` that value is returned, and the filter to the right of the operator is never even executed. If the filter on the left does produce `null` or `false`, then the filter to the right is executed and its result returned.

That probably sounds more complicated than it is, the way I think of it is that if the filter to the left doesn't produce a real value, then the filter to the right is used instead.

As an example, let's print out the overall motivation for each prize that doesn't have any winners, or, the number of winners for each prize in our Nobel Prizes data set:

```bash
jq '.prizes[] | .overallMotivation // (.laureates | length )' NobelPrizes.json
```

## Regular Expressions

LEFT OFF HERE!!!

## Debugging

## External Files

## Variables?

## EPISODE DIVIDER â€” MANIPULATING DATA

## Mathematical Operators

## String Manipulation

### String Interpolation

### The `sub` function

### Any other string functions of Note

## Array Manipulation

### Sorting

### Deduplication

### The `map` Function

## Constructing new Outputs

### String Interpolation

Build a string describing Andrea Ghez's prize:

```bash
jq '.prizes[] | .laureates[]? | select(.surname == "Ghez") | "\(.firstname) \(.surname) was awarded her prize for \(.motivation)"' NobelPrizes.json --raw-output
# Andrea Ghez was awarded her prize for "for the discovery of a supermassive compact object at the centre of our galaxy"
```

### Array Construction

Most common use is to re-combine multiple outputs from a filter into a single array for final output or to pipe to the next filter in the chain.

Often used as a syntactically shorter alternative to the `map` function.

### Dictionary Construction

Get the details of Dr. Andrea Ghez's Nobel prize as a new dictionary:

```bash
# Basic example â€” just extract top-level values
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year, prize: .category}' NobelPrizes.json
# {
#  "year": "2020",
#  "prize": "physics"
# }

# Complex example â€” combine top-level and lower-level data, use string interpolation, and use string substitution
jq '.prizes[] | select(any(.laureates[]?; .surname == "Ghez")) | {year: .year, prize: .category, name: (.laureates[] | select(.surname == "Ghez") | "\(.firstname) \(.surname)"), citation: (.laureates[] | select(.surname == "Ghez") | .motivation | sub("\""; ""; "g"))}' NobelPrizes.json
# {
#  "year": "2020",
#  "prize": "physics",
#  "name": "Andrea Ghez",
#  "citation": "for the discovery of a supermassive compact object at the centre of our galaxy"
#}
```

## EPISODE BREAK â€” JQ as a Programming Language

## Defining Variables

Potential example â€” prizes with and above average number of winners

## Conditionals

## Loops

