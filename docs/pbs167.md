## PBS 167 of X — jq: Some Advanced Topics

TO DO

## Matching Podcast Episode

TO DO

## Installment Resources

* The instalment ZIP file — [pbs167.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs167.zip) TO CREATE

## PBS 166 Challenge Solution

The final js challenge in this series-within-a-series was to use the `map`, `map_values`, and `reduce` functions we learned about in [the previous instalment](./pbs166) to refactor and enrich a domain data breach report from the wonderful [Have-I-Been-Pwnd](https://haveibeenpwned.com) service (HIBP) in two ways:

1. Remove the top-level `.Breaches` and `.Pastes` keys, and have the contents of the `.Breaches` lookup table become the top-level element. 
2. Use `map_values` to replace the value of each key in the new top-level lookup table (initially a simple array of breach names) with a dictionary that contains two keys:
   1. `Breaches` — an array of dictionaries indexed by `Name`, `Title` & `DataClasses` . Use the `map` function to process the entire array in one step.
   2. `ExposureScore` — a value calculated from the enriched breach details that starts at 0, and adds 1 for each breach the user is caught up in that does not contain passwords, and 10 for each breach that does. Use the `reduce` function to perform this calculation.

We'll use the dummy HIBP export for the imaginary domain `demo.bartificer.net` to test our solution, and you'll find that export in the instalment ZIP as `hibp-pbs.demo.json`. To enrich the data we'll need an export of all the breaches HIBP knows, which we can download for free as described in [instalment 164](./pbs164). For convenience, the instalment ZIP includes a copy of the database as it was on the 4th of June 2024 in the file `hibp-breaches-20240604.json`.

You'll find a full sample solution in the file `pbs166-challengeSolution.jq` in the instalment zip:

```jq
# Enrich the breach data in a domain report from the Have-I-Been-Pwned service.
# Input:    JSON as downloaded from the HIBP service
# Output:   A Lookup-style dictionary with breach data for domain users indexed
#   by email username (the part to the left of the @). For each user lookup
#   table maps to a dictionary indexed by:
#   - Breaches:         An array of dictionaries describing the breaches the
#                       user was snared in.
#   - Exposure Score:   A measure of how exposed the user is.
# Variables:
# - $breachDetails	An array containing a single entry, the JSON for the
#                   latest lookup table of HIBP breaches indexed by breach
#                   name

# Keep just the Breach details
.Breaches

# re-build the values for every key
| map_values({
    # build the enriched breach data
    Breaches: map({
        Name: .,
        Title: $breachDetails[0][.].Title,
        DataClasses: $breachDetails[0][.].DataClasses
    }),

    # calculate the exposure score
    ExposureScore: (reduce .[] as $breachName (0; 
        . + (($breachDetails[0][$breachName].DataClasses | contains(["Passwords"]) // empty | 10 ) // 1 )
    ))
})
```

As you can see, promoting the breaches lookup table to the top-level element is as simple as filtering down to it by name, so that is simply `.Breaches`.

At the top level we now have a lookup table with arrays if breach names indexed by email usernames like this:

```json
{
  "josullivan": [
    "OnlinerSpambot"
  ],
  "egreen": [
    "Dropbox"
  ],
  "mwkelly": [
    "Dropbox",
    "KayoMoe",
    "LinkedIn",
    "LinkedInScrape",
    "PDL"
  ],
  "ahawkins": [
    "iMesh",
    "OnlinerSpambot"
  ],
  "ptraynor": [
    "Collection1"
  ]
}
```

We need to transform the values in this lookup table from arrays of strings to arrays of dictionaries, so we'll start by wrapping all our work in a call to `map_values`. The first thing we will need the filter passed as the only argument to `map_values` to do is construct a new dictionary with two keys, `Breaches` and `ExposureScore`, so big-picture wise our solution will be structured like this:

```jq
| map_values({
    # build the enriched breach data
    Breaches: SOMETHING,
    ExposureScore: SOMETHING
})
```

Let's look at how to calculate each value in turn, starting with the new breaches list. The input to this filter will be a single current value from the top-level dictionary, so something like:

```json
[
  "iMesh",
  "OnlinerSpambot"
]
```

That is to say, we have an array of strings, and we want an array of dictionaries. We transform the strings to dictionaries without exploding and re-capturing the array using the `map` function. In the filter passed as the only argument to `map`, the current value will be a single breach name as a string. That means that this part of our solution will have the following basic form:

```jq
map({
  Name: SOMETHING,
  Title: SOMETHING,
  DataClasses: SOMETHING
})
```

Since the original value being transformed is a breach name, `Name` can simply be given the value `.`. The name is also used to index our list of all known breaches from HIBP, so if we import that list into our script with `--slurpfile` and give it the name `$breachDetails` then we can get the title and data classes with `$breachDetails[0][.].Title` & `$breachDetails[0][.].DataClasses`. Remember, `--slurpfile` wraps the data it imports into an array in case there are multiple values, so our lookup table is not at `$breachDetails`, but at `$breachDetails[0]`.  Putting all that together we can calculate our new enrich arrays of breach details with:

```jq
map({
  Name: .,
  Title: $breachDetails[0][.].Title,
  DataClasses: $breachDetails[0][.].DataClasses
})
```

The final piece of the puzzle is to calculate our exposure score. Here we are condensing a list of breaches into a single number, so we are *reducing* an array, hence, we use the `reduce` operator. We start with an exposure score of `0`, and for each breach that has no passwords we add `1`, and for each breach that does have passwords we add `10`. We can figure out whether or not a breach has passwords using our enrichment data in `$breaches[0]` — if the array `breachDetails[0][$breachName].DataClasses` contains the string `Passwords` then the breach contained passwords. One small subtlety to remember is that to use the `contains` function to check array containment rather than substring containment we need to pass an array **both** as input **and** as the argument, so it needs to be `contains(["Passwords"])` rather than simply `contains("Passwords")`.

Next, we need to add the appropriate amount each time, and the key to that is the *alternate* operator, or `//`. Remember that if the left-hand-side evaluates to anything that's not `empty`, `false`, or `null`, then the right-hand-side is evaluated. In effect, we need to implement the simple logic *'if true, evaluate to 10, and if false evaluate to 1'*. Because we've not yet learned about jq's `if` operator we need to achieve this logic with the *alternative operator* (`//`), which is actually quite tricky!

The key to making this work is that if you pipe any value to a filter with a literal value the output is that literal value, e.g.:

```sh
# -n for no input
jq -n 'true | 10' # outputs 10
```

But, if you pipe nothing to anything, the pipe never happens, so the output is still nothing, i.e. `empty`. We can prove this to ourselves with the following commands which pipe nothing to a filter with a literal value  — both output nothing at all rather than `10`:

```sh
# create then explode an empty array
jq -n '[] | .[] | 10' # no output

# explicitly send no input
jq -n 'empty | 10' # no output
```

We can use this jq behaviour in conjunction with two *alternative* operators to get our `1` or `10` as appropriate with:

```jq
(($breachDetails[0][$breachName].DataClasses | contains(["Passwords"]) // empty | 10 ) // 1
```

To understand why this works, let's break it down for a breach which does contain passwords, and then again for one that doesn't. Note that the output from the `contains` filter will be `true` or `false`. 

So, when a breach does contain a password what we in effect have is:

```jq
(true // empty | 10 ) // 1
```

The first alternative operator has a value on the left that is not `empty`, `null`, or `false`, so the right-hand-side never happens, and  `true` gets piped to the filter `10`, producing a `10` on the left of the second alternative operator, so it's right-hand side also does not happen, and the final output is `10`.

Now, what happens when the breach does not contain a password? In that case we effectively have:

```jq
(false // empty | 10 ) // 1
```

In this case the left-hand-side of the first alternative operator is `false`, so the right-hand-side does happen, and `empty` gets piped to `10`, producing `empty` as the left-hand-side of the second alternative operator. This means that it's right-hand-side happens too, so the final output is `1`.

Finally, wet have all the pieces we need to use the `reduce` operator:

```jq
(reduce .[] as $breachName (0; 
  . + (($breachDetails[0][$breachName].DataClasses | contains(["Passwords"]) // empty | 10 ) // 1 )
))
```

That's all the pieces of our solution filled out, so we can now see it in action with:

```sh
jq --slurpfile breachDetails hibp-breaches-20240604.json -f pbs166-challengeSolution.jq hibp-pbs.demo.json
```

This gives us lots of output, including the following entry for `mwkelly`:

```json
"mwkelly": {
  "Breaches": [
    {
      "Name": "Dropbox",
      "Title": "Dropbox",
      "DataClasses": [
        "Email addresses",
        "Passwords"
      ]
    },
    {
      "Name": "KayoMoe",
      "Title": "Kayo.moe Credential Stuffing List",
      "DataClasses": [
        "Email addresses",
        "Passwords"
      ]
    },
    {
      "Name": "LinkedIn",
      "Title": "LinkedIn",
      "DataClasses": [
        "Email addresses",
        "Passwords"
      ]
    },
    {
      "Name": "LinkedInScrape",
      "Title": "LinkedIn Scraped Data (2021)",
      "DataClasses": [
        "Education levels",
        "Email addresses",
        "Genders",
        "Geographic locations",
        "Job titles",
        "Names",
        "Social media profiles"
      ]
    },
    {
      "Name": "PDL",
      "Title": "Data Enrichment Exposure From PDL Customer",
      "DataClasses": [
        "Email addresses",
        "Employers",
        "Geographic locations",
        "Job titles",
        "Names",
        "Phone numbers",
        "Social media profiles"
      ]
    }
  ],
  "ExposureScore": 32
},
```

The first thing to note is just how much enrichment we have added, this was their original entry:

```json
[
  "Dropbox",
  "KayoMoe",
  "LinkedIn",
  "LinkedInScrape",
  "PDL"
]
```

Secondly, notice that two of the five breaches had no passwords, and three did, so the exposure score was correctly calculated as `10+10+10+1+1` which gives `32`.

## Traditional(ish) if-statements

Most of the time jq does not need traditional `if` statements, the alternative (`//`) or error suppression (`?`) operators are usually sufficient, and they're much simpler than a traditional conditional statement, but, as our challenge solution illustrates perfectly, sometimes things get really messy when you limit yourself to those operators!

It\'s fair to say the following implementation of *'10 if there are passwords in the breach, otherwise 1'* is neither concise nor clear:

```jq
(($breachDetails[0][$breachName].DataClasses | contains(["Passwords"]) // empty | 10 ) // 1
```

Clearly, the following is better in every way:

```jq
if $breachDetails[0][$breachName].DataClasses | contains(["Passwords"]) then 10 else 1 end
```

This is an example of the longest form of the `if` statement in jq, for which the syntax is as follows, with `CONDITION` being a filter that evaluates to a boolean, and `TRUE_VALUE` and `FALSE_VALUE` being filters called to generate the output when the condition evaluates to `true` or `false` respectively:

```jq
if CONDITION then TRUE_VALUE else FALSE_VALUE end
```

The file `pbs166-challengeSolution-if.jq` in the instalment ZIP contains a version of the PBS 166 challenge solution with the confusing double-alternative-operator line above replaced with the much clearer `if`-statement (also above). We can see that does exactly the same thing by getting `mwkelly`'s exposure score with both scripts:

```sh
# Note: a trailing \ at the end of a line allows a shell
#       command to be split over multiple lines

# the script with the alternative operator
jq --slurpfile breachDetails hibp-breaches-20240604.json -f pbs166-challengeSolution.jq hibp-pbs.demo.json \
| jq '.mwkelly.ExposureScore'
# outputs 32

# the script with the if statement
jq --slurpfile breachDetails hibp-breaches-20240604.json -f pbs166-challengeSolution-if.jq hibp-pbs.demo.json \
| jq '.mwkelly.ExposureScore'
# outputs 32

```

For a simpler example, the following command will square numbers but preserve their sign, i.e. `2` will become `4` and `-2` will become `-4`:

```sh
# -c for compact output
jq -nc '[-2, -1, 0, 1, 2] | map(if . < 0 then 0 - (. * .) else . * . end)'
# output: [-4,-1,0,1,4]
```

### Using the Implied `else`

Like in other languages, you can use `if` statements without a matching `else` in jq:

```jq
if CONDITION then TRUE_VALUE end
```

However, the implicit default `else` filter may catch you by surprise. 

In most languages, the implied `else` is *do nothing*, for example, the following JavaScript `if` statements do the same thing:

```js
let x;

// implied else
x = 5;
if(x < 0){
	x += 10;  
}
console.log(x) // outputs 5

// equivalent explicit else
x = 5;
if(x < 0){
	x += 10;
}else{
  ; //explicitly do nothing
}
console.log(x) // outputs 5
```

You'll find this code in `pbs167a-impliedElse.js` in the instalment ZIP, and if you have the [NodeJS](https://nodejs.org/) JavaScript interpreter installed, you can run it with the command:

```js
node ./pbs167a-impliedElse.js
```

In jq the implied else `.`, i.e., the implied else is *pass the input un-changed*. In other words, **when you omit the `else` and the condition is `false`, the output is the input**! To help me remember this detail I mentally think of `if` in jq as *'alter if'*.

The following two statements are identical:

```jq
# implied else
5 | if . < 0 then . + 10 end
# results in 5

# equivalent explicit else
,5 | if . < 0 then . + 10 else . end
# results in 5
```

You'll find this code in `pbs167a-impliedElse.jq` in the instalment ZIP, and you can run it with the command:

```sh
jq -nf pbs167a-impliedElse.jq
```

## Try-catch

When your data is just a little variable it's easy enough to work around it using the error suppression operator `?` , or, by normalising the data, but when your data is very noisy that can become very tedious. That's where jq's `try`-`catch` operator comes in. You can contain the filter(s) that handle the noisy data within a `try` statement, and then define your response in case of any error at all in the matching `catch` filter.

The syntax is simply as shown below, where `ERROR_PRONE_FILTER` and `ERROR_HANDLING_FILTER` are jq filters:

```jq
try ERROR_PRONE_FILTER catch ERROR_HANDLING_FILTER
```

The jq interpreter will try the `ERROR_PRONE_FILTER` and if it runs without error, then its output will be used, but if it triggers an error that error will be prevented from stopping execution like it normally would, and the error string will be passed to the `ERROR_HANDLING_FILTER` as its input (`.`), and the output of that filter will be used instead. Note that **the input to the catch is the error string**, not the original input! Sadly, there's no way I have found to access the original input from within the `ERROR_HANDLING_FILTER`.

How you choose to deal with errors is up to you — you could output the error as a string of some kind, you could output some kind of default value, or you could remove the problem input from the processing chain by returning `empty`. Let's use our Nobel Prises data set to illustrate each approach.

We're going to use a rather contrived example so we can intentionally trigger an error on some, but not all, of our data. The rather esoteric problem we're going to solve is to output the number of letters in the names of all the winners of each Nobel physics prise in the 1940s as an array. This works as an example because we need to dive into the array of laureates within the prizes to get the lengths of their names, and, there are years in the 1940s where no prizes were awarded, so those entries have no `.laureates` array at all.

Before we explore our options for handling errors, let's remind ourselves what happens when we don't handle our errors! The file `pbs167b1-noErrorHandling.jq` in the instalment ZIP does the needed calculations without any error handling:

```jq 
# Output the number of letters in the names of the laureates who were awarded
# Nobel prizes in physics each year in the 1940s.
# Input:    The official list of Nobel Prizes in JSON format
# Output:   an array of numbers

# filter down to just the physics prizes in the appropriate years
.prizes | map(
    (.year | tonumber) as $year
    | select($year >= 1940 and $year < 1950 and .category == "physics")

    # calculate the number of letters in the laureate names without error handling
    .laureates | map("\(.firstname)\(.surname)" | length) | add
)
```

When we try to run it we get an error message, and no output:

```sh
jq -f pbs167b1-noErrorHandling.jq NobelPrizes.json
# jq: error (at NobelPrizes.json:0): Cannot iterate over null (null)
```

The line that does the calculation and throws the error is:

```jq
.laureates | map("\(.firstname)\(.surname)" | length) | add
```

So, this is the filter we'll add our error handling to in the examples below.

### Outputting Errors as Strings

The simplest thing we can do is simply convert the error into output. Because the input to the `catch` filter is the error message as a string, we can simply output the error with `catch .`. You can see this in context in the file `pbs167b2-rawError.jq`:

```jq
# try calculate the number of letters in the laureate names
| try (
  .laureates | map("\(.firstname)\(.surname)" | length) | add
)
# if there is an error, output the error as-is
catch .
```

If we run this script we can see it now completes, and the errors appear in the output array as strings:

```sh
jq -f pbs167b2-rawError.jq NobelPrizes.json
# [
#   12,
#   20,
#   17,
#   16,
#   13,
#   16,
#   9,
#   "Cannot iterate over null (null)",
#   "Cannot iterate over null (null)",
#   "Cannot iterate over null (null)"
# ]
```

We can of course add some context around our error as illustrated in `pbs167b3-enrichedError.jq`:

```jq
catch "Failed to calculate total name length for \($year) with error: \(.)"
```

We can see this in action with the command:

```sh
jq -f pbs167b3-enrichedError.jq NobelPrizes.json
# [
#   12,
#   20,
#   17,
#   16,
#   13,
#   16,
#   9,
#   "Failed to calculate total name length for 1942 with error: Cannot iterate over null (null)",
#   "Failed to calculate total name length for 1941 with error: Cannot iterate over null (null)",
#   "Failed to calculate total name length for 1940 with error: Cannot iterate over null (null)"
# ]
```

Of course, there's no need to include the cryptic error messages from jq itself at all, as demonstrated in `pbs167b4-humanError.jq`:

```jq
catch "No laureates in \($year)!"
```

This gives the following:

```sh
jq -f pbs167b4-humanError.jq NobelPrizes.json
# [
#   12,
#   20,
#   17,
#   16,
#   13,
#   16,
#   9,
#   "No laureates in 1942!",
#   "No laureates in 1941!",
#   "No laureates in 1940!"
# ]
```

### Outputting Default Values

If your output is intended to be consumed by a human it makes sense to give a nice error message, but if your output is intended to be processed by another computer, then it's better to output a sane default value. In our case, the length of all the names when there are no names is zero!  The file `pbs167b5-default.jq` outputs `0` when there's an error:

```jq
catch 0
```

We can see this in action with the command:

```sh
jq -f pbs167b5-default.jq NobelPrizes.json
# [
#   12,
#   20,
#   17,
#   16,
#   13,
#   16,
#   9,
#   0,
#   0,
#   0
# ]
```

### Silently Swallowing Errors

Finally, we can choose to have errors simply vanish by outputting `empty` when something goes wrong, as per `pbs167b6-swallowErrors.jq`:

```jq
catch 0
```

Which we can see in action with the command:

```sh
jq -f pbs167b6-swallowErrors.jq NobelPrizes.json
# [
#   12,
#   20,
#   17,
#   16,
#   13,
#   16,
#   9
# ]
```

### The Implied `catch`

Like with `if` statements, the `catch` is optional, and if you leave it out, there is an implied action, which is to silently swallow the error, so `try ERROR_PRONE_FILTER` is equivalent to `try ERROR_PRONE_FILTER catch empty` .

The file `pbs167b7-impliedCatch.jq` illustrates this:

```jq
# try calculate the number of letters in the laureate names
| try ( .laureates | map("\(.firstname)\(.surname)" | length) | add )
```

We can see this in action with the command:

```sh
jq -f pbs167b7-impliedCatch.jq NobelPrizes.json
# [
#   12,
#   20,
#   17,
#   16,
#   13,
#   16,
#   9
# ]
```

## Complex Assignment

LEFT OFF HERE!!!

## Recursive descent with `recurse`

Most sensible example is a directory tree, can generate with: https://www.npmjs.com/package/dir-to-json

## MAYBE — Traditional Loops with `foreach`, `while`, `until` & MAYBE `repeat`



## Final Thoughts

TO DO
