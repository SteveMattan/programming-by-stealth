## PBS 162 of X — jq: Altering Arrays & Dictionaries

TO DO

## Matching Podcast Episode

TO DO

## Installment Resources

* The instalment ZIP file — [pbs162.zip](https://github.com/bartificer/programming-by-stealth/raw/master/instalmentZips/pbs162.zip) TO CREATE

## PBS 161 Challenge Solution

TO DO

## Altering Arrays

Now that we've seen how to alter strings, let's take a look at way of transforming arrays.

### Re-Ordering Arrays (`sort` & `reverse`)

Let's start with the simplest type of array transformation — re-orderings.

The simplest re-ordering is a straight forward reversing, and jq provides just that with the `reverse` function:

```sh
jq -nc '[1, 2, 3] | reverse' # outputs [3,2,1]
```

Then of course we have array sorting.

When you have an array with simple values the built-in `sort` function will generally do what you want.

The function requires an array as input, and it will first group elements by type, starting with any `null` elements, then any booleans, then numbers, then strings, then arrays, and finally dictionaries. Within each grouping it will then perform the most sensible sorting, `false` before `true` for Booleans, numeric sorting for numbers, and alphabetic (lexical) sorting for strings. (Note that the rules for sorting arrays and dictionaries exist, but are out of the scope of this series).

Let's see the `sort` function in action:

```sh
# numbers
jq -nc '[1, 4, 3] | sort' # outputs [1,3,4]

# strings
jq -nc '["popcorn", "waffles",  "pancakes"] | sort' 
# outputs ["pancakes","popcorn","waffles"]

# mixed types
jq -nc '[42, true, 11, "waffles", false,  "pancakes"] | sort'
# outputs [false,true,11,42,"pancakes","waffles"]
```

When dealing with arrays containing more complicated elements like other arrays or dictionaries, you probably want to specify your own rule for sorting, you can do this with th `sort_by` function. It takes as an argument a filter, and that filter will be applied to each array element, and the elements will be sorted based on the results of applying the filter. Usually the filter is simply a dictionary key.

For example, we can re-order our menu (from the `menu.js` file in the instalment ZIP), with:

```sh
jq 'sort_by(.price)' menu.json
```

This outputs:

```json
[
  {
    "name": "pancakes",
    "price": 3.10,
    "stock": 43
  },
  {
    "name": "hotdogs",
    "price": 5.99,
    "stock": 143
  },
  {
    "name": "waffles",
    "price": 7.50,
    "stock": 14
  }
]
```

As you can see, the array is now sorted by price.

### Adding and Removing Elements with the  `+` & `-` Operators

As mentioned earlier, the `+` operator has been overloaded to perform a useful action when both inputs are arrays — it merges them into a new bigger array:

```sh
# Note: -n for no input & -c for compact output
jq -nc '[1, 2] + [3, 4]' # outputs [1,2,3,4]
```

While the `-` operator is not overloaded for strings, it is overloaded for arrays, and can be used create a new array with elements removed. The array to the left of the `-` is treated as the original array, and the elements in the array to the right of the `-` are removed from the original array, if present, to create the output array.

```sh
jq -nc '[1, 2, 3, 4] - [4, 5]' # outputs [1,2,3]
```

### Array Deduplication

When you start adding arrays together it's easy to end up with duplucates that you may well not want. The jq language provides two useful functions for removing them.

Firstly, the simple `unique` function returns the input array sorted with any duplicated elements removed. The input must be an array. For exmaple:

```sh
jq -nc '[4, 1, 4, 3, 2] | unique' # outputs [1,2,3,4]
```

If you need a more complex definition of 'uniqueness' you can use the `unique_by` function to supply your own filter as an argument. The output array will only contain one element which the filter evaluates to a given value. If multiple elements evaluate to the same value, one will be kept, but there's no guarantee as to which one it will be. Also note that the elements in the output array will be sorted based on the result of the filter.

As a somewhat contrived example, we can make our menu (from `menu.json` above) unique by length of name. Before we do, let's compute the lengths see what results we expect, we can do that with:

```sh
jq '.[] | .name | length' menu.json
```

This shows that hotdogs and waffles have 7 letters, and pancakes 8. We would expect to always get pancakes in our answer, but only one of waffles or hotdogs when we make the menu unique by name. Let's try:

```sh
jq 'unique_by(.name | length)' menu.json
```

This gives us the output:

```json
[
  {
    "name": "hotdogs",
    "price": 5.99,
    "stock": 143
  },
  {
    "name": "pancakes",
    "price": 3.10,
    "stock": 43
  }
]
```

As expected, we get one item with a name of length 7, the one with a name of length 8, because the items are sorted on the result of the filter as well as deduplicated based on it.

### Flattening Nested Arrays

When assembling an array from multiple sources you may end up with an array of arrays when you actually wanted a single unified array. This is where the built-in `flatten` function comes in.

The `flatten` function takes an array as in input, and if it contains other arrays, it replaces them with their entries in the output array. The funtion applies this logic recursively, so you if your array contains arrays which contain arrays, it will still flatten them all out to a single array of all the values.

```sh
jq -nc '[1, [2, 3], [4, [5, 6]]] | flatten'
# outputs [1,2,3,4,5,6]
```

By default the flatten function will keep recursing down into all nested arrays, but you can pass an optional argument to limit how deep it goes. To see what this means, let's repeat our above example with limits of 2 and 1:

```sh
# limit to a depth of 2
# arrays in the input array, and arrays in arrays in the input array
jq -nc '[1, [2, 3], [4, [5, 6]]] | flatten(2)'
# outputs [1,2,3,4,5,6]

# limit to a depth of 1
# arrays in the input array only
jq -nc '[1, [2, 3], [4, [5, 6]]] | flatten(1)'
# outputs [1,2,3,4,[5,6]]
```

## Dictionary Manipulation

### Adding and Removing Keys

As mentioned earlier, the `+` operators is overloaded for handling dicrtionaries. When two dictionaries are added together, a new dictionary is created containing the keys and values from both. If both input dictionaries define a value for the same key, the value from the dictionary on the right of the `+` operator is used.

If the dictionaries contain dictionaries, a recursive merge can be done by using the `*` operator instead of the `+` operator.

You might imagine key could comehow be removed with an overloaded subtraction operator, but alas not, we need to use the built-in `del` function for that. This function requires a dictionary as the input, and a key path as an argument. For example, we could remove the stock key from each item in our menu (`menu.js` from the instalment ZIP) with:

```sh
jq '.[] | del(.stock)' menu.json
```

Which returns:

```json
{
  "name": "hotdogs",
  "price": 5.99
}
{
  "name": "pancakes",
  "price": 3.10
}
{
  "name": "waffles",
  "price": 7.50
}
```

Note we expoloded the array in this example, so we now have a list of separate output values instead of a single array. We can combin the `del` function with the `map` function to avoid exploding the array:

```sh
jq 'map(del(.stock))' menu.json
```

This returns a single array containing the updated dictionaries:

```json
[
  {
    "name": "hotdogs",
    "price": 5.99
  },
  {
    "name": "pancakes",
    "price": 3.10
  },
  {
    "name": "waffles",
    "price": 7.50
  }
]
```

## Converting Lookup-Style Dictionaries to Arrays of Dictionaries

TO DO `to_entries` & `from_entries`

Good example is JSON returned by HIBP

```sh
jq '.Breaches | to_entries | [ .[] | select(.key | startswith("bob")) ] | from_entries' hibp.json
```

## An Optional Challenge

TO DO

## Final Thoughts

TO DO

# EPISODE BREAK — jq: In-Place Array & Dictionary Manipulation

At this stage in our jq journey we've met many operators and functions which can manipulate data, but each time we've applied a transformation to each element in an array we've done so by exploding it apart updating each piece, and then re-assembling it. We've never even considered applying the same transformation to every value in a dictionary, because based purely on what we've learned so far, we couldn't put the dictionary back together again!

What if you could edit the contents of arrays and dictionaries without ever needing to explode them? As you've probably guessed from the setup, you can! And, this entire instalment is dedicated to doing just that with two of jq's most powerful functions, `map` & `map_values`.

MAYBE — cover `reduce` too

## Altering Each Element in an Array with the `map` Function

In most programming languages, you need to loop over arrays to manipulate their contents, but in jq you don't need to do that — you can simply pipe an array to the `map` function and describe the desired transformation with a filter passed as the first argument.

Within a the filter passed as the first argument to `map`,  `.` represents *'the array element being processed'*, and the filter will be applied to each element in the array. The function then outputs the updated array.

In effect, `map` lets you **loop over an aray in a single function call**, and **process each element without exploding the array**.

For example, we can convert all the numbers in an array to their absolute values with:

```sh
# -n tells jq not to expect any input
# -c tells jq to render the output in a compact format
jq -nc '[1, -2, 3, -42] | map(. | abs)'
# outputs [1,2,3,42]
```

One of the most common uses of `map` is in conjunction with `select`, allowing you filter an array down to only the elements that meet a particular criteria without needing to explode and then re-assemble it.

As an example, let's filter the Nobel Prizes data set down to an array with just the physics prizes, with their order reversed so the older prize comes first, and the newest last. Here's how we would do that without using `map`:

```sh
jq '[.prizes[] | select(.category == "physics")] | reverse' NobelPrizes.json
```

Note the need to explode the prizes with `.prizes[]`, and then to re-assemble the array by wrapping the exposion and the `select` filters in square brackets ( `[` & `]`).

With `map`, we can simplify things:

```sh
jq '.prizes | map(select(.category == "physics")) | reverse' NobelPrizes.json
```

We now have a simple filter chain without the need for nesting part of it within square brackets, making it easier to read and to maintain.

Note that this technique works because the `select` function returns `empty` rather than `null` when called with a value that does not match the specified criteria, transforming un-matched entries into absolute nothingless, hence deleting them!

One final point to note — `map` will not give an error when the input is a dictionary, it will simply treat the values within the key-value pairs as array elements, and output an array of their processed results. At first glance this might seem useless, how often do you have a dictionary who's keys you don't need? But actually, it is occassionaly useful, imagine you have weekly sales data in dictionary indexed by day-of-the-week, like so (`weeklySales.json` in the instalment ZIP):

```json
{
  "mon": 2343,
  "tue": 4324,
  "wed": 4121,
  "thur": 8762,
  "fri": 11452,
  "sat": 32394,
  "sun": 0
}
```

To convert this to an array of numbers we can call `map` with a filter that passes the values through un-changed, i.e. simply `.`:

```sh
jq -c 'map(.)' weeklySales.json # outputs [2343,4324,4121,8762,11452,32394,0]
```

Notice that the values in the array are in the order the keys were added to the dictionary, not in any kind of sorted order.

## The `map_values` Function

In many ways the `map_values` function is very similar to the `map` function, but while `map` is primarily designed for processing arrays, `map_values` is primarily designed for processing dictionaries.

It's structure is the same — the input should be a dictionary, and its argument is a filter to be applied to each value in the dictionary to produce a new value in the output dictionary, and within the filter, `.` is the value currently being processed.

So, to double all the sales data in our weekly sales dictionary, we would run the command:

```sh
jq 'map_values(. * 2)' weeklySales.json
```

This produces the following dictionary:

```json
{
  "mon": 4686,
  "tue": 8648,
  "wed": 8242,
  "thur": 17524,
  "fri": 22904,
  "sat": 64788,
  "sun": 0
}
```

Similar to how `map` does not throw an error when passed a dictionary, `map_values` will not throw an error when you pass it an array, it will simply process the array, and return an updated array (not a dictionary).

## Beware the Subtle Difference between `map` & `map_values` 

With `map`, when a filter maps a single input values to multiple output values, they all appear in the output array, but `map_values` will only include the first generated value for each input.

As a somewhat contrived example to illustrate this difference, let's pass an array of arrays to both functions and see what happens when we use a filter that explodes these sub-arrays:

```sh
# use map to explode sub-arrays
jq -nc '[[1], [2, 2], [3, 3, 3]] | map(.[])' # outputs [1,2,2,3,3,3]

# try use map_values to explode sub-arrays
jq -nc '[[1], [2, 2], [3, 3, 3]] | map_values(.[])' # outputs [1,2,3]
```

## The `reduce` Function 

TO DO - MAYBE

# EPISODE BREAK — jq: Some Advanced Topics

## Traditional Loops with `foreach`, `while`, `until` & MAYBE `repeat`

## MAYBE — Recursive descent with `recurse`

Most sensible example is a directory tree, can generate with: https://www.npmjs.com/package/dir-to-json

## Variables & Loops with `as`

Potential example — prizes with and above average number of winners

## If-the-else

## Try-catch

